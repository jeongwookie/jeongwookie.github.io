<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeongwook&#39;s Blog</title>
  
  <subtitle>Make stuff people want</subtitle>
  <link href="/newblogtest/atom.xml" rel="self"/>
  
  <link href="https://jeongwookie.github.io/newblogtest/"/>
  <updated>2019-03-24T08:08:43.434Z</updated>
  <id>https://jeongwookie.github.io/newblogtest/</id>
  
  <author>
    <name>Jeongwook, Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>네이버 api 연동하여 데이터 추출하기</title>
    <link href="https://jeongwookie.github.io/newblogtest/2019/03/20/190320-collect-data-using-naver-search-api/"/>
    <id>https://jeongwookie.github.io/newblogtest/2019/03/20/190320-collect-data-using-naver-search-api/</id>
    <published>2019-03-20T02:17:11.000Z</published>
    <updated>2019-03-24T08:08:43.434Z</updated>
    
    <content type="html"><![CDATA[<p>이번 포스트는 네이버 개발자 센터에서 제공하는 검색 api를 통해 우리가 원하는 키워드를 검색하고, 그 결과를 json파일로 저장하는 것을 다루어보겠다.</p><p>json파일로 저장하는 이유는 <code>pandas</code>와 같은 데이터 분석 툴을 사용할 때, import하기 좋은 파일 형식이기 때문이다.</p><p>아래와 같은 순서로 진행한다.</p><ul><li>Step 1: 네이버 개발자센터 등록 및 키 값 받아오기</li><li>Step 2: api caller 만들기</li><li>Step 3: 데이터 수집 후 json 파일로 저장하기</li><li>Step 4: pandas 사용하여 분석하기</li></ul><a id="more"></a><h4 id="네이버-개발자센터-등록하기"><a href="#네이버-개발자센터-등록하기" class="headerlink" title="네이버 개발자센터 등록하기"></a>네이버 개발자센터 등록하기</h4><p>먼저 <a href="https://developers.naver.com/main/" target="_blank" rel="noopener">네이버 개발자 센터</a>에 접속하여 Application -&gt; 애플리케이션 등록 을 클릭한다.</p><p>아래와 같은 화면이 뜨는데, 검색 api 누르고 안드로이드 설정에서 적당한 이름을 넣으면 된다. (com.블라블라)</p><p><img src="https://user-images.githubusercontent.com/25416425/54655089-e75b0d80-4b03-11e9-80cd-fdb8a1c8e654.png" width="550"></p><p>완료하게 되면, 애플리케이션 정보에 client ID와 client secret 코드가 보이는데 이걸 어딘가 안전한 곳에 복사해둔다. (노출 절대 금지)</p><h4 id="api-caller-만들기"><a href="#api-caller-만들기" class="headerlink" title="api caller 만들기"></a>api caller 만들기</h4><p>이제, 네이버 검색 api를 불러올 caller 을 만들어 보자.</p><p>아까 전 네이버 개발자 센터 홈페이지에서 Documents -&gt; 서비스 API -&gt; 검색을 누르면 아래와 같은 페이지가 뜬다. 코드는 python으로 클릭.</p><p><img src="https://user-images.githubusercontent.com/25416425/54655436-43726180-4b05-11e9-8385-1dc66ae2e745.png" width="550"></p><p>여기 있는 코드를 긁어서 오면 아래와 같다. 중간에 <code>YOUR_CLIENT_ID</code>와 <code>YOUR_CLIENT_SECRET</code>에는 아까 복사해 두었던 키값들을 기입한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 네이버 검색 API예제는 블로그를 비롯 전문자료까지 호출방법이 동일하므로 blog검색만 대표로 예제를 올렸습니다.</span></span><br><span class="line"><span class="comment"># 네이버 검색 Open API 예제 - 블로그 검색</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">client_id = “YOUR_CLIENT_ID”</span><br><span class="line">client_secret = “YOUR_CLIENT_SECRET”</span><br><span class="line">encText = urllib.parse.quote(“검색할 단어”)</span><br><span class="line">url = “https://openapi.naver.com/v1/search/blog?query=" + encText # json 결과</span><br><span class="line"><span class="comment"># url = ”https://openapi.naver.com/v1/search/blog.xml?query=" + encText # xml 결과</span></span><br><span class="line">request = urllib.request.Request(url)</span><br><span class="line">request.add_header(“X-Naver-Client-Id”,client_id)</span><br><span class="line">request.add_header(“X-Naver-Client-Secret”,client_secret)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">rescode = response.getcode()</span><br><span class="line"><span class="keyword">if</span>(rescode==<span class="number">200</span>):</span><br><span class="line">    response_body = response.read()</span><br><span class="line">    print(response_body.decode(‘utf<span class="number">-8</span>’))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(“Error Code:” + rescode)</span><br></pre></td></tr></table></figure><p>샘플 코드의 주석에 적힌 대로, 현재 이 코드는 키워드를 받아서 블로그를 검색한 결과를 보여준다.</p><p>코드가 너무 기니까 조금 간략하게 바꾸어 보자. 대충 이런 식이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"> </span><br><span class="line">keyword = “”</span><br><span class="line">url = “https://openapi.naver.com/v1/search/blog?query=" + keyword</span><br><span class="line">result = requests.get(urlparse(url).geturl(),</span><br><span class="line">                      headers=&#123;“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,</span><br><span class="line">                             “X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”&#125;)</span><br><span class="line">json_obj = result.json()</span><br><span class="line">print(json_obj)</span><br></pre></td></tr></table></figure><p>위 코드는 <code>keyword</code> 를 받아서 네이버 검색 api를 거친 후 <code>json_obj</code>를 반환한다.</p><p>이제 call을 하는 함수를 만들어 보자. 키워드를 입력한 후, 그 검색 결과를 한번에 100개씩 받아오는 함수를 작성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(keyword, start)</span>:</span></span><br><span class="line">    encText = quote(keyword)</span><br><span class="line">    url = “https://openapi.naver.com/v1/search/blog?query=" + encText </span><br><span class="line">        + “&amp;display=<span class="number">100</span>” + “&amp;start=” + str(start)</span><br><span class="line">    result = requests.get(url=url, headers=&#123;“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,</span><br><span class="line">                                          “X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”&#125;)</span><br><span class="line">    print(result)  <span class="comment"># Response [200]</span></span><br><span class="line">    <span class="keyword">return</span> result.json()</span><br></pre></td></tr></table></figure><p><code>&amp;display=100</code>은 한번에 100개의 검색 결과를 보여준다는 것이고, <code>&amp;start=</code>은 그 뒤의 숫자에 따라 어느 순서의 검색 결과부터 출력하는지를 결정한다. </p><p>뒤의 숫자는 그냥 두면 <code>int</code> 속성을 가지게 되므로, <code>str()</code>을 사용하여 <code>string</code>으로 바꾸어 url을 완성시킨다.</p><h4 id="데이터-수집-후-저장하기"><a href="#데이터-수집-후-저장하기" class="headerlink" title="데이터 수집 후 저장하기"></a>데이터 수집 후 저장하기</h4><p>이제, 검색 결과를 한번에 1000개 수집하여 json 파일로 저장해 보자.</p><p>모듈화를 위해 libs 폴더 내 naver_api_call 폴더를 만들고, 그 내부에 먼저 api_caller.py 파일을 만들어 작성하였다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># api_caller.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 네이버 api call</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(keyword, start)</span>:</span></span><br><span class="line">    encText = quote(keyword)</span><br><span class="line">    url = “https://openapi.naver.com/v1/search/blog?query=" + encText + </span><br><span class="line">    “&amp;display=<span class="number">100</span>” + “&amp;start=” + str(start)</span><br><span class="line">    result = requests.get(url=url, headers=&#123;“X-Naver-Client-Id”:“YOUR_CLIENT_ID”,</span><br><span class="line">                                          “X-Naver-Client-Secret”:“YOUR_CLIENT_SECRET”&#125;)</span><br><span class="line">    print(result)  <span class="comment"># Response [200]</span></span><br><span class="line">    <span class="keyword">return</span> result.json()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1000개의 검색 결과 받아오기</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get1000results</span><span class="params">(keyword)</span>:</span></span><br><span class="line">    list = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        list = list + call(keyword, num * <span class="number">100</span> + <span class="number">1</span>)[‘items’] <span class="comment"># list 안에 키값이 ’item’인 애들만 넣기</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure><p>함수들을 만들었으니, 이제 실제로 사용해 보자. 우리가 할 일은 네이버 api call을 하고, 1000개의 키워드 검색 결과를 받아온 후, 이를 json파일에 저장하는 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 01_collect.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> libs.naver_api_call.api_caller <span class="keyword">import</span> get1000results</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"> </span><br><span class="line">list = []</span><br><span class="line">result = get1000results(“강남역 맛집”)</span><br><span class="line">result_2 = get1000results(“강남역 찻집”)</span><br><span class="line">list = list + result + result_2</span><br><span class="line"> </span><br><span class="line">file = open(“./gangnam.json”, “w+”)  <span class="comment"># gangnam.json 파일을 쓰기 가능한 상태로 열기 (만들기)</span></span><br><span class="line">file.write(json.dumps(list))  <span class="comment"># 쓰기</span></span><br></pre></td></tr></table></figure><p>위 코드를 출력하면 정상적으로 <code>gangnam.json</code>이 디렉토리에 생성됨을 확인할 수 있다.</p><h4 id="pandas-사용하여-분석하기"><a href="#pandas-사용하여-분석하기" class="headerlink" title="pandas 사용하여 분석하기"></a>pandas 사용하여 분석하기</h4><p><code>pandas</code>는 여러가지 분석에 유용한 함수들을 제공하여, 길고 긴 json 파일을 보다 쉽고 빠르게 파악할 수 있도록 돕는다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 02_analyze_pd.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line">df = pd.read_json(“./gangnam.json”)</span><br><span class="line">print(df.count())  <span class="comment"># 각 key 별 숫자 출력</span></span><br><span class="line"> </span><br><span class="line">df_sum = df.groupby(“bloggername”).count()  <span class="comment"># groupby() 함수를 사용하여 bloggername별로 출력</span></span><br><span class="line">print(df_sum)</span><br><span class="line"> </span><br><span class="line">bloggernames = df[‘bloggername’]  <span class="comment"># bloggername 만 출력</span></span><br><span class="line">print(bloggernames)</span><br></pre></td></tr></table></figure><p><code>count()</code> 는 json 파일에 저장된 각각의 key값에 대한 데이터 숫자를 세어준다. 우리는 위에서 “강남역 맛집”으로 검색한 결과 1000개, 그리고 “강남역 찻집”으로 검색한 결과 1000개로 총 2000개의 결과값을 저장해 두었었다.</p><p><code>groupby()</code> 는 지정한 key값으로 결과값을 그룹화하여 보여준다. 결과값을 보면 어떤 bloggername을 가진 사람이 우리가 지정한 키워드에 대해서 블로깅을 많이 하였는지 알 수 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/54686400-8a3f7600-4b5c-11e9-8715-315304fda0d8.png" width="550"></p><p>세 번째 출력값은 현재 저장된 json 파일에서 bloggername 을 전부 출력해 본 것이다. 총 1640개의 블로그가 수집되었음을 알 수 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/54687073-100ff100-4b5e-11e9-8eda-8465816a34be.png" width="550"></p><blockquote><p>위 포스트는 Kyeongrok Kim님의 네이버 api 불러오기 예시를 실습해보고, 이를 간단히 정리한 것임을 밝힙니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이번 포스트는 네이버 개발자 센터에서 제공하는 검색 api를 통해 우리가 원하는 키워드를 검색하고, 그 결과를 json파일로 저장하는 것을 다루어보겠다.&lt;/p&gt;
&lt;p&gt;json파일로 저장하는 이유는 &lt;code&gt;pandas&lt;/code&gt;와 같은 데이터 분석 툴을 사용할 때, import하기 좋은 파일 형식이기 때문이다.&lt;/p&gt;
&lt;p&gt;아래와 같은 순서로 진행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: 네이버 개발자센터 등록 및 키 값 받아오기&lt;/li&gt;
&lt;li&gt;Step 2: api caller 만들기&lt;/li&gt;
&lt;li&gt;Step 3: 데이터 수집 후 json 파일로 저장하기&lt;/li&gt;
&lt;li&gt;Step 4: pandas 사용하여 분석하기&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/newblogtest/tags/Python/"/>
    
      <category term="WEB Crawling" scheme="https://jeongwookie.github.io/newblogtest/tags/WEB-Crawling/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/newblogtest/tags/Datamining/"/>
    
  </entry>
  
  <entry>
    <title>네이버 금융에서 주식 가격 크롤링하기</title>
    <link href="https://jeongwookie.github.io/newblogtest/2019/03/18/190318-naver-finance-data-crawling-using-python/"/>
    <id>https://jeongwookie.github.io/newblogtest/2019/03/18/190318-naver-finance-data-crawling-using-python/</id>
    <published>2019-03-18T01:36:15.000Z</published>
    <updated>2019-03-24T08:06:30.745Z</updated>
    
    <content type="html"><![CDATA[<p>19년 3월부터 카이스트 데이터사이언스 연구실 (KAIST DS LAB)에서 일하기 시작했다.</p><p>가장 처음 맡은 일이 파이썬으로 특정 데이터들을 웹에서 크롤링하는 것인데, 예전에 <code>BeautlfulSoup4</code>으로 간단하게 몇 가지 다루어 본 것을 복습하는 겸 포스트를 작성하기로 했다. </p><p>기본적으로 작업은 파이참 (pyCharm)으로 진행했다.</p><a id="more"></a><h3 id="네이버-금융-웹에서-봉차트-데이터-수집하기"><a href="#네이버-금융-웹에서-봉차트-데이터-수집하기" class="headerlink" title="네이버 금융 웹에서 봉차트 데이터 수집하기"></a>네이버 금융 웹에서 봉차트 데이터 수집하기</h3><p>아래와 같은 순서로 진행한다.</p><ul><li>Step 1: 특정 종목의 가격 받아오기</li><li>Step 2: 여러 종목의 가격 받아오기</li><li>Step 3: 특정 종목의 봉차트 데이터 받아오기</li><li>Step 4: 여러 종목의 봉차트 데이터 받아오기</li></ul><p>시작하기 전, interpreter가 제대로 설치되어 있는지 체크하자.</p><p>우리가 이번에 사용할 패키지는 <code>requests</code> 와 <code>beautifulsoup4</code>이다.</p><p>맥에서는 preference -&gt; project interpreter에 가면 다운로드 및 확인이 가능하고,</p><p>윈도우에서는 file -&gt; setting -&gt; project interpreter에 가면 마찬가지로 확인이 가능하다.<br><img src="https://user-images.githubusercontent.com/25416425/54502101-45ed8380-496c-11e9-9ae6-d4de73d8a23b.png" width="550"><center> 맥에서 파이참 preference을 열었을 때 </center></p><h4 id="특정-종목의-가격-받아오기"><a href="#특정-종목의-가격-받아오기" class="headerlink" title="특정 종목의 가격 받아오기"></a>특정 종목의 가격 받아오기</h4><p>요즘 펄어비스가 신작을 발표하면서 주식 가격이 떡상(?)하고 있다. 개인적으로 관심이 가는 회사니까.. 여기 데이터를 한번 가져와 보자.</p><p>먼저 <a href="https://finance.naver.com/" target="_blank" rel="noopener">네이버 금융</a>에 접속해서 펄어비스를 검색해 보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54502363-8ef20780-496d-11e9-92b9-06bb0abe0c6e.png" width="550"><center> 빨간색 네모가 우리가 가져가고 싶은 데이터 </center></p><p>저 빨간색 네모 안의 숫자가 우리가 크롤링 하고 싶은 펄어버스 주식의 현재 가격이다. 크롬 (chrome)의 개발자 도구를 켜서 위치를 확인하자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54502950-7800e480-4970-11e9-85ac-7924cfa59680.png" width="550"><br><img src="https://user-images.githubusercontent.com/25416425/54503082-f9587700-4970-11e9-9615-e26feae53448.png" width="550"><br>이제 코드를 짜면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line">url = “https://finance.naver.com/item/main.nhn?code=263750"</span><br><span class="line">result = requests.get(url)</span><br><span class="line">bs_obj = BeautifulSoup(result.content, “html.parser”)</span><br><span class="line"> </span><br><span class="line">no_today = bs_obj.find(“p”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “no_today”&#125;) <span class="comment"># 태그 p, 속성값 no_today 찾기</span></span><br><span class="line">blind = no_today.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;) <span class="comment"># 태그 span, 속성값 blind 찾기</span></span><br><span class="line">now_price = blind.text</span><br><span class="line"> </span><br><span class="line">print(now_price)</span><br></pre></td></tr></table></figure><p>실행하면 <code>now_price</code>가 187,500이 제대로 출력됨을 확인할 수 있다.<br>(실시간으로 가격 변동이 발생 ㅠㅠ)</p><h4 id="여러-종목의-가격-받아오기"><a href="#여러-종목의-가격-받아오기" class="headerlink" title="여러 종목의 가격 받아오기"></a>여러 종목의 가격 받아오기</h4><p>자세히 보면, 우리가 입력한 url의 제일 뒤 숫자 6자리가 <strong>회사 코드</strong>임을 알 수 있다.</p><p>이를 원하는 코드로 바꿈으로써, 여러 회사들의 주식 가격을 가져올 수 있다.</p><p>위 코드에 대해서 <code>company_code</code>를 입력하면 <code>now_price</code>를 출력할 수 있도록 리팩토링 (refactoring) 해보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line"><span class="comment"># company_code를 입력받아 bs_obj를 출력</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bs_obj</span><span class="params">(company_code)</span>:</span></span><br><span class="line">    url = “https://finance.naver.com/item/main.nhn?code=" + company_code</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    bs_obj = BeautifulSoup(result.content, “html.parser”)</span><br><span class="line">    <span class="keyword">return</span> bs_obj</span><br><span class="line"> </span><br><span class="line"><span class="comment"># company_code를 입력받아 now_price를 출력</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(company_code)</span>:</span></span><br><span class="line">    bs_obj = get_bs_obj(company_code)</span><br><span class="line">    no_today = bs_obj.find(“p”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “no_today”&#125;)</span><br><span class="line">    blind = no_today.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;)</span><br><span class="line">    now_price = blind.text</span><br><span class="line">    <span class="keyword">return</span> now_price</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 펄어비스 회사 코드는 ”263750”</span></span><br><span class="line"><span class="comment"># 삼성전자 회사 코드는 ”005930”</span></span><br><span class="line"><span class="comment"># 셀트리온 회사 코드는 ”068270”</span></span><br><span class="line">company_codes = [“<span class="number">263750</span>”, “<span class="number">005930</span>”, “<span class="number">068270</span>”]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> company_codes:</span><br><span class="line">    now_price = get_price(item)</span><br><span class="line">    print(now_price)</span><br></pre></td></tr></table></figure><p>실행하면, 펄어비스와 삼성전자, 그리고 셀트리온의 현재 주식 가격을 잘 받아오고 있음을 확인할 수 있다.</p><h4 id="특정-종목의-봉차트-데이터-받아오기"><a href="#특정-종목의-봉차트-데이터-받아오기" class="headerlink" title="특정 종목의 봉차트 데이터 받아오기"></a>특정 종목의 봉차트 데이터 받아오기</h4><p>이번에는 펄어비스의 전일, 고가, 시가, 저가 주식 데이터를 가져와 보자.</p><p>아까와 마찬가지로 먼저 데이터의 위치를 개발자 도구를 사용하여 알아보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54504757-4a1f9e00-4978-11e9-86ae-c3a715769c4a.png" width="550"><br><img src="https://user-images.githubusercontent.com/25416425/54504673-e4cbad00-4977-11e9-8a58-1abd7043586f.png" width="550"><br>빨간색 네모 안에 전일 주식 가격이 들어있음을 확인한 후, 코드를 짜보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line">url = “https://finance.naver.com/item/main.nhn?code=263750"</span><br><span class="line">result = requests.get(url)</span><br><span class="line">bs_obj = BeautifulSoup(result.content, “html.parser”)</span><br><span class="line"> </span><br><span class="line">td_first = bs_obj.find(“td”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “first”&#125;)  <span class="comment"># 태그 td, 속성값 first 찾기</span></span><br><span class="line">blind = td_first.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;)  <span class="comment"># 태그 span, 속성값 blind 찾기</span></span><br><span class="line">close = blind.text</span><br><span class="line"> </span><br><span class="line">print(close)</span><br></pre></td></tr></table></figure><p>전일 (close)에 해당하는 펄어비스의 주식 가격이 제대로 출력되고 있다.</p><p>위와 같은 방법으로, 고가 (high), 시가 (open), 저가 (low)에 대한 데이터의 위치를 찾아서 코딩하면 된다.</p><p>주의할 점은, <code>find()</code> 함수는 가장 처음 만나는 태그를 반환하므로, 그 뒤의 동일한 이름의 태그를 찾고 싶다면 <code>find_all()</code> 함수를 사용해야 한다.</p><p>또한, <code>find_all()</code>은 리스트 (list)를 반환한다.</p><p>대략적으로 각 데이터의 위치를 아래에 그려 보았다.<br><img src="https://user-images.githubusercontent.com/25416425/54505445-2ad64000-497b-11e9-8ac2-05785fa16ed5.png" width="550"></p><p><code>tr</code> 태그가 두 개, 그리고 각각의 태그 안에 <code>td</code> 태그가 세 개씩 있고, 첫 번째 <code>td</code>는 다행히도 속성값이 명시되어 있지만 두 번째 <code>td</code>부터는 그렇지 않다.</p><p>위와 같은 형태일 때는 모두를 포함하면서 속성값을 가지고 있어, 전체 데이터에서 특정지을 수 있는 태그부터 찾아서 narrow down해야 한다.</p><p>이번에는 그 역할로 <code>table</code> 태그의 속성값 <code>no_info</code>를 사용할 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line">url = “https://finance.naver.com/item/main.nhn?code=263750"</span><br><span class="line">result = requests.get(url)</span><br><span class="line">bs_obj = BeautifulSoup(result.content, “html.parser”)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#close 종가(전일)</span></span><br><span class="line">td_first = bs_obj.find(“td”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “first”&#125;)  <span class="comment"># 태그 td, 속성값 first 찾기</span></span><br><span class="line">blind = td_first.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;)  <span class="comment"># 태그 span, 속성값 blind 찾기</span></span><br><span class="line">close = blind.text</span><br><span class="line"> </span><br><span class="line"><span class="comment"># high 고가</span></span><br><span class="line">table = bs_obj.find(“table”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “no_info”&#125;)  <span class="comment"># 태그 table, 속성값 no_info 찾기</span></span><br><span class="line">trs = table.find_all(“tr”)  <span class="comment"># tr을 list로 []</span></span><br><span class="line">first_tr = trs[<span class="number">0</span>]  <span class="comment"># 첫 번째 tr 지정</span></span><br><span class="line">tds = first_tr.find_all(“td”)  <span class="comment"># 첫 번째 tr 안에서 td를 list로</span></span><br><span class="line">second_tds = tds[<span class="number">1</span>]  <span class="comment"># 두 번째 td 지정</span></span><br><span class="line">high = second_tds.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line"><span class="comment"># open 시가</span></span><br><span class="line">second_tr = trs[<span class="number">1</span>]  <span class="comment"># 두 번째 tr 지정</span></span><br><span class="line">tds_second_tr = second_tr.find_all(“td”)  <span class="comment"># 두 번째 tr 안에서 td를 list로</span></span><br><span class="line">first_td_in_second_tr = tds_second_tr[<span class="number">0</span>]  <span class="comment"># 첫 번째 td 지정</span></span><br><span class="line">open = first_td_in_second_tr.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line"><span class="comment"># low 저가</span></span><br><span class="line">second_td_in_second_tr = tds_second_tr[<span class="number">1</span>]  <span class="comment"># 두 번째 td 지정</span></span><br><span class="line">low = second_td_in_second_tr.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line">print(close)</span><br><span class="line">print(high)</span><br><span class="line">print(open)</span><br><span class="line">print(low)</span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면, 펄어비스의 봉차트 주식 데이터가 제대로 출력됨을 확인할 수 있다.</p><h4 id="여러-종목의-봉차트-데이터-받아오기"><a href="#여러-종목의-봉차트-데이터-받아오기" class="headerlink" title="여러 종목의 봉차트 데이터 받아오기"></a>여러 종목의 봉차트 데이터 받아오기</h4><p>이제 위 코드에 대해서 <code>company_code</code>를 입력하면 봉차트 데이터를 출력할 수 있도록 리팩토링 (refactoring) 해보자.</p><p>입력값은 <code>company_code</code>이고, 리턴값은 <code>close</code>, <code>high</code>, <code>open</code>, <code>low</code>인 함수를 짜면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bs_obj</span><span class="params">(company_code)</span>:</span></span><br><span class="line">    url = “https://finance.naver.com/item/main.nhn?code=" + company_code</span><br><span class="line">    result = requests.get(url)</span><br><span class="line">    bs_obj = BeautifulSoup(result.content, “html.parser”)</span><br><span class="line">    <span class="keyword">return</span> bs_obj</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_candle_chart</span><span class="params">(company_code)</span>:</span></span><br><span class="line">    bs_obj = get_bs_obj(company_code)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># close 종가(전일)</span></span><br><span class="line">    td_first = bs_obj.find(“td”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “first”&#125;)  <span class="comment"># 태그 td, 속성값 first 찾기</span></span><br><span class="line">    blind = td_first.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;)  <span class="comment"># 태그 span, 속성값 blind 찾기</span></span><br><span class="line">    close = blind.text</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># high 고가</span></span><br><span class="line">    table = bs_obj.find(“table”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “no_info”&#125;)  <span class="comment"># 태그 table, 속성값 no_info 찾기</span></span><br><span class="line">    trs = table.find_all(“tr”)  <span class="comment"># tr을 list로 []</span></span><br><span class="line">    first_tr = trs[<span class="number">0</span>]  <span class="comment"># 첫 번째 tr 지정</span></span><br><span class="line">    tds = first_tr.find_all(“td”)  <span class="comment"># 첫 번째 tr 안에서 td를 list로</span></span><br><span class="line">    second_tds = tds[<span class="number">1</span>]  <span class="comment"># 두 번째 td 지정</span></span><br><span class="line">    high = second_tds.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># open 시가</span></span><br><span class="line">    second_tr = trs[<span class="number">1</span>]  <span class="comment"># 두 번째 tr 지정</span></span><br><span class="line">    tds_second_tr = second_tr.find_all(“td”)  <span class="comment"># 두 번째 tr 안에서 td를 list로</span></span><br><span class="line">    first_td_in_second_tr = tds_second_tr[<span class="number">0</span>]  <span class="comment"># 첫 번째 td 지정</span></span><br><span class="line">    open = first_td_in_second_tr.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># low 저가</span></span><br><span class="line">    second_td_in_second_tr = tds_second_tr[<span class="number">1</span>]  <span class="comment"># 두 번째 td 지정</span></span><br><span class="line">    low = second_td_in_second_tr.find(“span”, &#123;“<span class="class"><span class="keyword">class</span>”:</span> “blind”&#125;).text</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> &#123;“close”: close, “high”: high, “open”: open, “low”: low&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 펄어비스 회사 코드는 ”263750”</span></span><br><span class="line"><span class="comment"># 삼성전자 회사 코드는 ”005930”</span></span><br><span class="line"><span class="comment"># 셀트리온 회사 코드는 ”068270”</span></span><br><span class="line">company_codes = [“<span class="number">263750</span>”, “<span class="number">005930</span>”, “<span class="number">068270</span>”]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> company_codes:</span><br><span class="line">    candle_chart = get_candle_chart(item)</span><br><span class="line">    print(candle_chart)</span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면 펄어비스, 삼성전자, 셀트리온의 주식 봉차트 데이터가 순서대로 출력됨을 확인할 수 있다.</p><p>다음 포스트에서는 조금 더 복잡한 데이터 크롤링을 다루어 보겠다.</p><blockquote><p>위 포스트는 Kyeongrok Kim님의 데이터 크롤링 예시를 실습해보고, 이를 간단히 정리한 것임을 밝힙니다.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;19년 3월부터 카이스트 데이터사이언스 연구실 (KAIST DS LAB)에서 일하기 시작했다.&lt;/p&gt;
&lt;p&gt;가장 처음 맡은 일이 파이썬으로 특정 데이터들을 웹에서 크롤링하는 것인데, 예전에 &lt;code&gt;BeautlfulSoup4&lt;/code&gt;으로 간단하게 몇 가지 다루어 본 것을 복습하는 겸 포스트를 작성하기로 했다. &lt;/p&gt;
&lt;p&gt;기본적으로 작업은 파이참 (pyCharm)으로 진행했다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/newblogtest/tags/Python/"/>
    
      <category term="WEB Crawling" scheme="https://jeongwookie.github.io/newblogtest/tags/WEB-Crawling/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/newblogtest/tags/Datamining/"/>
    
  </entry>
  
  <entry>
    <title>R을 사용한 데이터 시각화, 2편</title>
    <link href="https://jeongwookie.github.io/newblogtest/2019/03/08/190308-data-visualization-using-R-2/"/>
    <id>https://jeongwookie.github.io/newblogtest/2019/03/08/190308-data-visualization-using-R-2/</id>
    <published>2019-03-08T07:06:15.000Z</published>
    <updated>2019-03-24T08:23:53.665Z</updated>
    
    <content type="html"><![CDATA[<p>지난 포스트에서는 기본적인 plot을 그리는 방법과, 가장 널리 쓰이는 패키지인 ggplot2을 간단히 다루어 보았다.</p><p>이번 포스트에서는 내장 데이터셋을 Barplot (막대 그래프) 으로 표현해 볼 것이다.</p><p>library는 마찬가지로 <code>gglpot2</code> <code>plotrix</code> <code>boot</code> <code>scatterplot3d</code> <code>lattice</code> <code>MASS</code> 을 기본으로 한다.</p><a id="more"></a><h3 id="데이터셋-sleep으로-Barplot-그리기"><a href="#데이터셋-sleep으로-Barplot-그리기" class="headerlink" title="데이터셋 sleep으로 Barplot 그리기"></a>데이터셋 sleep으로 Barplot 그리기</h3><p>먼저 <strong>sleep</strong>가 어떤 형태인지부터 보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54420514-84f1be00-474d-11e9-833d-22eb7ab4cf8c.png" alt></p><p>열이 세개로, 각각 extra, group, ID 라는 이름을 가지고 있다.</p><p>ID는 각각의 사람을 의미하고, group은 실험의 상태를 분류하며, extra는 이에 대한 결과값이다.</p><p>이제 x축은 ID, y축은 extra, 그리고 group별로 다른 색상을 나타내는 Barplot을 그려 보자.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head(sleep)</span><br><span class="line"><span class="keyword">attach</span>(sleep) <span class="comment">#sleep내의 objects(extra, group, ID)를 이름으로 쉽게 접근가능</span></span><br><span class="line">y &lt;- rbind(extra[<span class="number">1</span>:<span class="number">10</span>], extra[<span class="number">11</span>:<span class="number">20</span>]) <span class="comment">#group별로 extra값을 나누어 row bind 시킴. form : num</span></span><br><span class="line">barplot(y, names.arg = ID[<span class="number">1</span>:<span class="number">10</span>], col = <span class="number">5</span>:<span class="number">6</span>, xlab = <span class="string">"ID"</span>, ylab = <span class="string">"Extra Sleep Hour"</span>, beside = <span class="literal">T</span>)</span><br><span class="line"><span class="comment"># beside는 논리값으로, True이면 값을 병렬적으로, False이면 값을 쌓아서 반환함</span></span><br><span class="line">abline(h=<span class="number">0</span>) <span class="comment">#높이가 0인 line을 덧그림</span></span><br><span class="line">legend(<span class="string">'topleft'</span>, title = <span class="string">'group'</span>, legend = <span class="number">1</span>:<span class="number">2</span>, fill = <span class="number">5</span>:<span class="number">6</span>) <span class="comment"># legend 추가</span></span><br></pre></td></tr></table></figure><p><strong>결과</strong><br><img src="https://user-images.githubusercontent.com/25416425/54420947-adc68300-474e-11e9-9d39-6d4eaae4db11.png" width="450"></p><p><code>attatch()</code>는 데이터를 붙인다는 뜻인데, 데이터 내의 오브젝트에 이름으로 접근이 가능해진다.</p><p>그래서 바로 아랫줄에서 <code>extra[1:10]</code> 이런 식으로 서술이 가능하고, 이를 <code>rbind()</code>을 사용하여 행렬로 만든다.</p><p><code>barplot()</code>을 사용하려면 제일 앞에 들어가는 y를 이처럼 vector 혹은 matrix 형태로 바꾸어 주어야 한다.</p><p>함수 내부의 <code>beside=</code> 옵션은 TRUE일 때 데이터를 병렬적으로 보여주고, FALSE이면 하나의 막대에 전부 합쳐서 출력한다.</p><h3 id="데이터셋-sleep으로-Barplot-그리기-ggplot2"><a href="#데이터셋-sleep으로-Barplot-그리기-ggplot2" class="headerlink" title="데이터셋 sleep으로 Barplot 그리기 (ggplot2)"></a>데이터셋 sleep으로 Barplot 그리기 (ggplot2)</h3><p>이번에는 동일한 barplot을 <code>ggplot2</code> 패키지를 사용해서 그려보자. 함수는 <code>geom_bar()</code>을 사용한다.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">ggplot(sleep, aes(x=ID, y=extra, fill = group))+ <span class="comment"># fill은 면의 컬러를 채울때 사용 </span></span><br><span class="line">  geom_bar(stat = <span class="string">"identity"</span>, position = <span class="string">"dodge"</span>)+ <span class="comment"># stat값을 identity로 지정하면 y 데이터를 높이로 사용</span></span><br><span class="line">  <span class="comment"># position을 default로 놔두면 값이 쌓아지고, dodge를 할당하면 병렬적으로 출력됨</span></span><br><span class="line">  theme_bw() <span class="comment"># data가 더 잘보이기 위한 테마</span></span><br></pre></td></tr></table></figure><p><strong>결과</strong><br><img src="https://user-images.githubusercontent.com/25416425/54421682-4ad5eb80-4750-11e9-9866-e0b3094a2b87.png" width="450"></p><p>먼저 <code>ggplot()</code>에서 인풋 데이터를 지정하고, aes 안에 x,y축 데이터를 지정하였는데 그다음에 <code>fill = group</code>이라는 옵션을 사용하였다.</p><p>대단히 자주 쓰이는 표현으로, <u>group에 따라 면의 컬러를 다르게 칠하라는 뜻</u>이다.</p><p><code>geom_bar()</code>은 본 패키지에서 barplot을 그리게 하는 함수로, 가장 자주 쓰이는 옵션이 바로 <code>stat=</code> 과 <code>position=</code>이다.</p><p><strong>stat</strong>은 statistic의 약자로, 바 그래프의 형태에 대해서 지정하는 옵션이다. <code>stat=&#39;identity&#39;</code>라고 쓰게 되면, y축 데이터를 높이로 하는 바 그래프를 그리라는 뜻이다.</p><p><strong>position</strong>은 막대의 위치를 의미하며, <code>position=&#39;dodge&#39;</code>는 여러 데이터를 독립적인 바 그래프로 나란히 표현할 때 사용한다. 이 옵션을 표기하지 않으면 데이터가 하나의 막대로 표시된다. </p><p><img src="https://user-images.githubusercontent.com/25416425/54422623-401c5600-4752-11e9-9ba1-526d71c32915.png" width="450"></p><center> position=dodge 를 표기하지 않았을 때 </center><h3 id="데이터셋-USPersonalExpenditure으로-Barplot-그리기"><a href="#데이터셋-USPersonalExpenditure으로-Barplot-그리기" class="headerlink" title="데이터셋 USPersonalExpenditure으로 Barplot 그리기"></a>데이터셋 USPersonalExpenditure으로 Barplot 그리기</h3><p>먼저 <strong>USPersonalExpenditure</strong>가 어떤 형태인지 알아보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54423376-e74dbd00-4753-11e9-9c56-3c657d5f3e6a.png" width="500"></p><p>Matrix의 형태로, 행에는 지출 항목, 그리고 열에는 년도가 기록되어 있다. 이들이 만나는 곳에는 실제 지출의 크기가 표기되어 있다.</p><p>이제 이 데이터를 최대한 잘 파악하기 위해, 년도별로 지출의 크기를 각 항목으로 나누어 바 그래프를 그려 보자.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data(USPersonalExpenditure) <span class="comment"># Global Environment에 데이터 추가</span></span><br><span class="line">UPE &lt;- USPersonalExpenditure <span class="comment"># 너무 길어서 간략화</span></span><br><span class="line">str(UPE) <span class="comment">#데이터의 form확인 : num</span></span><br><span class="line">barplot(UPE, beside = <span class="literal">T</span>, col = <span class="number">2</span>:<span class="number">6</span>, xlab = <span class="string">"Year"</span>, ylab = <span class="string">"Expenditure ($)"</span>, main = <span class="string">"United States Personal Expenditures"</span>)</span><br><span class="line">legend(<span class="string">'topleft'</span>, legend = row.names(UPE), fill = <span class="number">2</span>:<span class="number">6</span>, cex = <span class="number">0.7</span>) <span class="comment"># legend의 이름을 data의 row.name으로</span></span><br></pre></td></tr></table></figure><p><strong>결과</strong><br><img src="https://user-images.githubusercontent.com/25416425/54423687-968a9400-4754-11e9-9f62-b28064818b10.png" width="450"></p><p>원하는 대로 깔끔하게 data visualization 에 성공했다!</p><p>앞선 <strong>sleep</strong>와 마찬가지로 데이터를 병렬적으로 표기하기 위해 <code>beside=T</code> 옵션을 넣었고, 각각의 막대 컬러를 2번 ~ 6번 색상으로 다르게 지정했다.</p><p>그리고 <code>legend()</code>를 사용하여 따로 범례를 추가하였는데, 범례 이름은 <strong>UPE</strong>의 행 이름으로 지정했고, 색상은 <code>fill=</code>을 사용하여 앞서 지정하였던 막대 컬러 2~6번과 동일하게 하였다.</p><p>또한 <code>cex=</code>가 등장하였는데, 이는 글자 크기를 조절하는 데에 사용하며 비율로 결정되므로 적절히 조절해서 숫자를 넣으면 된다. 자주 쓰이는 옵션이니 기억해 두자.</p><p>이어지는 포스트에서는 barplot 외에 자주 쓰이는 pie chart 와 histogram에 대해 다루어 볼 예정이다.</p><blockquote><p><em>본 포스트는 KAIST 전산학부 대학원 과정에서 수강하고 있는 Big Data Analytics using R (CS564)을 실습하며 작성하였음을 밝힙니다.</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;지난 포스트에서는 기본적인 plot을 그리는 방법과, 가장 널리 쓰이는 패키지인 ggplot2을 간단히 다루어 보았다.&lt;/p&gt;
&lt;p&gt;이번 포스트에서는 내장 데이터셋을 Barplot (막대 그래프) 으로 표현해 볼 것이다.&lt;/p&gt;
&lt;p&gt;library는 마찬가지로 &lt;code&gt;gglpot2&lt;/code&gt; &lt;code&gt;plotrix&lt;/code&gt; &lt;code&gt;boot&lt;/code&gt; &lt;code&gt;scatterplot3d&lt;/code&gt; &lt;code&gt;lattice&lt;/code&gt; &lt;code&gt;MASS&lt;/code&gt; 을 기본으로 한다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="R programming" scheme="https://jeongwookie.github.io/newblogtest/tags/R-programming/"/>
    
      <category term="Class" scheme="https://jeongwookie.github.io/newblogtest/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>R을 사용한 데이터 시각화, 1편</title>
    <link href="https://jeongwookie.github.io/newblogtest/2019/03/06/190306-data-visualization-using-R-1/"/>
    <id>https://jeongwookie.github.io/newblogtest/2019/03/06/190306-data-visualization-using-R-1/</id>
    <published>2019-03-06T12:54:08.000Z</published>
    <updated>2019-03-24T07:55:30.856Z</updated>
    
    <content type="html"><![CDATA[<p>R은 데이터 시각화에 강력한 라이브러리들을 여럿 가지고 있어서 매우 유용하다.</p><p>이번 포스트에서 사용할 라이브러리는 아래와 같다.</p><p>library : <code>gglpot2</code> <code>plotrix</code> <code>boot</code> <code>scatterplot3d</code> <code>lattice</code> <code>MASS</code></p><a id="more"></a><p>먼저, 내장 데이터셋인 <strong>faithful</strong> 을 기본 함수 <code>plot()</code>을 통해 그려보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54251976-80ca7280-458c-11e9-99f8-fe3fbbb703b6.png" alt="faithful의 개략적 형태"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">head(faithful)</span><br><span class="line">fa &lt;- faithful[order(faithful$waiting),] </span><br><span class="line"><span class="comment"># waiting을 오름차순으로 정렬한 값을 fa에 저장</span></span><br><span class="line">head(fa)</span><br><span class="line">x &lt;- fa[,<span class="number">2</span>]; y &lt;- fa[,<span class="number">1</span>] </span><br><span class="line"><span class="comment"># waiting을 x에, eruptions을 y에 저장</span></span><br><span class="line">plot(x,y,type=<span class="string">"l"</span>, col=<span class="number">4</span>, xlab = <span class="string">"Waiting Time"</span>, ylab = <span class="string">"Eruption Time"</span>, main = <span class="string">"Old Faithful Eruptions"</span>)</span><br><span class="line">points(x,y, pch=<span class="number">20</span>, col=<span class="number">3</span>) </span><br><span class="line"><span class="comment"># pch는 점의 생김새를 의미, 20은 작은 점</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/54250526-76f24080-4587-11e9-8024-211abb8730cf.png" width="450"></p><p>fa는 <em>waiting</em> 열을 <code>order()</code>을 통해 정렬한 <strong>faithful</strong> 데이터를 기록한 것이다.</p><p>즉, fa[,1] = fa$eruptions 이고, fa[,2] = fa$waiting 이다.</p><p><code>plot()</code>은 type을 지정할 수 있으며, 여기서는 line을 나타내었다.</p><p><code>point()</code>는 말 그대로 점을 찍는 함수이며, 여기서 점의 생김새를 결정하는 <strong>pch=</strong> 를 한번 보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54250863-bbcaa700-4588-11e9-9085-411761ab6e28.png" width="300"></p><p>여러가지 타입이 있다는 것만 알면 된다. 중요한 것은 <strong>pch=</strong> 가 점의 타입을 결정하는 요소이며 자주 쓰이는 것이 <strong>pch = 20(점), 21, 22, 23, 24, 25</strong> 라는 사실이다.</p><p>이번에는 동일한 데이터를 <code>ggplot2</code> 패키지를 통해서 그려 보자.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">ggplot(fa, aes(x,y))+</span><br><span class="line">  geom_point(col=<span class="number">3</span>) + geom_line(col=<span class="number">4</span>) + <span class="comment"># 점을 찍을 때 geom_point를 사용</span></span><br><span class="line">  xlab(<span class="string">'Waiting time'</span>) + ylab(<span class="string">'Eruption time'</span>)+</span><br><span class="line">  ggtitle(<span class="string">'Old Faithful Eruption'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/54251159-bc177200-4589-11e9-8d10-8a0cbbc34cb9.png" width="450"></p><p>역시 <code>ggplot2</code> 답게 그래프 디자인이 조금 더 깔끔해 보인다.</p><p><code>ggplot()</code>함수는 어떤 데이터로 어느 축에 할당할 것인지 정한다. 이 함수만 출력하면 <u>아무것도 plot되지 않음에 주의하자.</u> 실제로 점을 찍고 선을 긋는 함수는 뒤에 있다.</p><p>자주 쓰이는 형태는 <code>ggplot(data, aes(x = , y = , fill = ))</code>으로, fill값에 대해서는 뒤에 다시 설명하겠다.</p><p><code>geom_point()</code>는 말그대로 점을 찍는 함수이다. 여기에도 여러가지 디자인 요소들이 있지만 자주 쓰이는 것은 <strong>col=</strong> 으로, 점의 색상을 결정한다.</p><p>이외에도 점의 모양을 결정하는 <strong>shape=</strong>, 점의 색상을 요소(factor)에 따라 변화하게 하는 <strong>aes(fill=)</strong>, 점의 크기를 결정하는 <strong>size=</strong> 등이 쓰이는데 자세한 것은 <a href="https://ggplot2.tidyverse.org/reference/geom_point.html" target="_blank" rel="noopener">여기</a>를 참고하자.</p><p><code>geom_line()</code>은 선을 긋는 함수이다. 마찬가지로 <strong>col=4</strong>라고 적음으로써 4번 색상인 파랑을 출력하고 있다. 자세한 디자인 요소 변경은 <a href="https://m.blog.naver.com/coder1252/221031694057" target="_blank" rel="noopener">여기</a>를 참고하자.</p><p>이번에는 또 다른 내장 데이터인 <strong>diamonds</strong> 를 <code>ggplot2</code>로 그려 보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/54252070-c6873b00-458c-11e9-934b-2f1d1fed3da7.png" alt="diamonds 데이터의 형태"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head(diamonds)</span><br><span class="line"><span class="keyword">library</span>(ggplot2)</span><br><span class="line">ggplot(diamonds, aes(x=carat, y=price)) +</span><br><span class="line">  geom_point(aes(col=color)) + <span class="comment"># point의 컬러(col)를 color라는 변수값에 따라 변하도록 설정</span></span><br><span class="line">  facet_grid(color ~ .) <span class="comment"># ~을 사용한 format</span></span><br></pre></td></tr></table></figure><p><code>ggplot()</code>에서 x축 데이터를 carat열, 그리고 y축 데이터를 price열 로 설정하였다.</p><p>그리고 <code>geom_point()</code>로 점을 찍는데, 그 점들의 색상을 <u>color열의 요소에 따라 달라지도록 지정하였다.</u></p><p>마지막으로, 새로운 함수가 하나 나타났는데 바로 <code>facet_grid()</code>.</p><p>주로 <strong>집단(group) 간의 효과적인 비교를 위해 면을 분할하고 싶을 때</strong> 사용한다.</p><p>또한, 많은 경우 <code>x ~ y</code>와 같은 형태로 작성하는데, 이는 표현 그대로 좌측은 x (input), 우측은 y (output)을 의미하는 간략한 함수 형태이다.</p><p>위의 <code>facet_grid(color ~ .)</code>은 color에 따라 나머지 모든 데이터를 그룹화 하여 면을 분할 해서 표현하라는 의미로 해석된다. 참고는 <a href="https://rfriend.tistory.com/85" target="_blank" rel="noopener">여기</a></p><p>만약 <code>facet_grid(. ~ color)</code>로 쓴다면, 쉽게 말해서 x와 y가 반전되어 출력된다. (세로)</p><div style="width:50%; height:300px; float:left;"><br><img src="https://user-images.githubusercontent.com/25416425/54253074-ba9d7800-4590-11e9-8bf7-eb477fea57fa.png" width="300"><br></div><div style="width:50%; height:300px; float:right;"><br><img src="https://user-images.githubusercontent.com/25416425/54253032-95106e80-4590-11e9-8cd2-03386699c406.png" width="300"><br></div><p>왼쪽은 <strong>facet_grid(color ~ .)</strong> 이고, 오른쪽은 <strong>facet_grid(. ~ color)</strong> 의 결과물이다. 위의 <code>geom_point()</code> 세팅에 따라, 점의 색상이 <strong>diamonds$color</strong>의 값에 따라 달라짐을 알 수 있다.</p><p>이어지는 포스트에서는 기본 plot외의 bar, histogram 등의 형태를 다루어 볼 것이다.</p><blockquote><p><em>본 포스트는 KAIST 전산학부 대학원 과정에서 수강하고 있는 Big Data Analytics using R (CS564)을 실습하며 작성하였음을 밝힙니다.</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;R은 데이터 시각화에 강력한 라이브러리들을 여럿 가지고 있어서 매우 유용하다.&lt;/p&gt;
&lt;p&gt;이번 포스트에서 사용할 라이브러리는 아래와 같다.&lt;/p&gt;
&lt;p&gt;library : &lt;code&gt;gglpot2&lt;/code&gt; &lt;code&gt;plotrix&lt;/code&gt; &lt;code&gt;boot&lt;/code&gt; &lt;code&gt;scatterplot3d&lt;/code&gt; &lt;code&gt;lattice&lt;/code&gt; &lt;code&gt;MASS&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="R programming" scheme="https://jeongwookie.github.io/newblogtest/tags/R-programming/"/>
    
      <category term="Class" scheme="https://jeongwookie.github.io/newblogtest/tags/Class/"/>
    
  </entry>
  
  <entry>
    <title>IBM Watson 다루기</title>
    <link href="https://jeongwookie.github.io/newblogtest/2019/01/22/190122-AI-development-training-course-in-kaist/"/>
    <id>https://jeongwookie.github.io/newblogtest/2019/01/22/190122-AI-development-training-course-in-kaist/</id>
    <published>2019-01-22T09:22:49.000Z</published>
    <updated>2019-03-24T07:55:39.508Z</updated>
    
    <content type="html"><![CDATA[<p>12월 말 정도부터 거의 매일 학교에서 저녁에 열렸던 AI 관련 특별 강좌를 이수했다.</p><p>원래는 TensorFlow 기본을 수강하려 했는데 수강 인원이 꽉 차버려서..ㅠㅠ</p><p>예전에 왓슨을 이용해서 간단한 챗봇은 구성해본 경험이 있어서, 왓슨의 다양한 기능들을 사용해 보고 프로젝트에 써먹을 수 있는 것이 있을까 파악하는 것도 재미있어 보였다.</p><p>이 수업에서는 기본적으로 <code>IBM Watson</code>의 다양한 기능들을 사용해보고, 이를 비즈니스에 실제로 적용할 때에 구성 방식에 대해서 배웠다.</p><a id="more"></a><p>제일 처음은 Watson Assistant를 사용한 피자 배달 챗봇 만들기부터 ㅋㅋㅋ</p><p>예전에 구성했던 챗봇은 선택지를 미리 정해놓고 케이스만 나누어서 응답하는 가장 기초적인 응답 챗봇이었기 때문에, 이번에는 선택지 없이 계속 케이스를 러닝 시키면서 accuracy가 올라가도록 구성해 보았다.</p><p>이후에는 Watson Discovery 및 Watson Knowledge Studio를 사용해서 기업 내부의 아카이브 된 지식 체계들을 쉽게 검색할 수 있도록 데모를 만들어 보았고.. 여러가지 검색어를 트라이 해보면서 놀았다.</p><p>Watson의 또 하나의 서비스인 Visual Recognition도 대단히 흥미로운 툴이었다. 분류자를 직접 만들어서 내가 가지고 있는 로컬 서버의 이미지 파일들을 정돈하는 데에 수 초가 걸리지 않았다. 결과도 꽤나 정확했던.. 물론 내가 직접 찍은 사진들은 너무 local스러워서 러닝이 더 필요해 보이긴 했지만.</p><p>새로운 툴을 만져 보는 것은 언제나 즐겁다. </p><p><img src="https://user-images.githubusercontent.com/25416425/51669137-250d4f80-2007-11e9-8a51-20661af4b714.png" alt="55시간에 걸친 수업 끝!!"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12월 말 정도부터 거의 매일 학교에서 저녁에 열렸던 AI 관련 특별 강좌를 이수했다.&lt;/p&gt;
&lt;p&gt;원래는 TensorFlow 기본을 수강하려 했는데 수강 인원이 꽉 차버려서..ㅠㅠ&lt;/p&gt;
&lt;p&gt;예전에 왓슨을 이용해서 간단한 챗봇은 구성해본 경험이 있어서, 왓슨의 다양한 기능들을 사용해 보고 프로젝트에 써먹을 수 있는 것이 있을까 파악하는 것도 재미있어 보였다.&lt;/p&gt;
&lt;p&gt;이 수업에서는 기본적으로 &lt;code&gt;IBM Watson&lt;/code&gt;의 다양한 기능들을 사용해보고, 이를 비즈니스에 실제로 적용할 때에 구성 방식에 대해서 배웠다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="KAIST IT Program" scheme="https://jeongwookie.github.io/newblogtest/tags/KAIST-IT-Program/"/>
    
      <category term="IBM Watson" scheme="https://jeongwookie.github.io/newblogtest/tags/IBM-Watson/"/>
    
      <category term="AI" scheme="https://jeongwookie.github.io/newblogtest/tags/AI/"/>
    
      <category term="Chatbot" scheme="https://jeongwookie.github.io/newblogtest/tags/Chatbot/"/>
    
  </entry>
  
  <entry>
    <title>우리 서비스의 시장 크기는 얼마나 될까?</title>
    <link href="https://jeongwookie.github.io/newblogtest/2018/09/18/180918-customer-discovery-kaist-e5/"/>
    <id>https://jeongwookie.github.io/newblogtest/2018/09/18/180918-customer-discovery-kaist-e5/</id>
    <published>2018-09-18T13:59:02.000Z</published>
    <updated>2019-03-24T08:25:06.546Z</updated>
    
    <content type="html"><![CDATA[<p>아닛..!! 저번주에 참여했던 KAIST E5 에서 놀랍게도 상금을 받으면서 2차 미션 대상팀이 되었다.</p><p>아무래도 주제가 좋지 않았나 싶다. 아직 많이 부족하지만..</p><p>아무튼 그래서 오늘은 2차 Mission 인 <strong>Customer Discovery</strong> 강의를 들으러 KAIST 스타트업 스튜디오 1층으로 모였다.</p><p>저번 비즈니스 모델링은 카카오벤처스 <strong>김기준 상무님</strong>께서 강연해 주셨고, 이번에는 씨엔티테크 <strong>전화성 대표님</strong>께서 직접 방문하셨다.</p><p><img src="https://user-images.githubusercontent.com/25416425/45695810-2c29da00-bb9d-11e8-9742-5bf801e04b03.png" width="550"></p><a id="more"></a><p>이번 2차 미션의 목표는, 1차 캠프에서 설계한 <u>우리의 비즈니스 모델이 정말 시장에서 통하는지</u> 그 가설을 검증하는 것이다.</p><p>대표님께서 처음 강연 시작 전, <strong>시장</strong>에 관하여 짧고 굵게 정의하셨는데 대단히 인상깊다.</p><blockquote><p>시장, 길게 설명할 것 없어. 나한테 돈을 주는 사람들의 집합이지.</p></blockquote><p>고객을 발견하는 일련의 과정은, 결국 내가 제시한 해결책이 효과적임을 입증하는 수단이다.</p><p>이를 세 가지 프로세스로 요약할 수 있다.</p><ol><li><p>진짜 공감되는 문제인가? (마켓의 문제를 입증하기)</p></li><li><p>내가 제시한 솔루션이 효과적인가?</p></li><li><p>1번과 2번의 결과를 보았을 때, 내가 뛰어들 마켓의 사이즈는 이정도다!</p></li></ol><p>그러면 구체적으로 위와 같은 의문을 어떻게 해결해야 할까?</p><p>답은 <strong>내가 돈 받을 사람한테 직접 가서 알아보는 수 밖에 없다!</strong></p><p>무엇이 힘든지, 얼마나 힘든지, 내가 이런 서비스를 만들껀데 어떤 기능이 당신에게 큰 도움이 될지 등 고객과의 <strong>Deep interwiew</strong>를 진행해야 한다.</p><p><strong>시장 규모 추정</strong>은 사업 계획서에 반드시 들어가는 항목이다.</p><p>그런데 의문이 들지 않는가?</p><p>내가 생각하는 서비스는 새로운 건데, 시장을 도데체 어떻게 숫자로 표현하라는 거지?</p><p>이를 제시하기 위한 유명한 툴이 있긴 하다.</p><p><img src="https://user-images.githubusercontent.com/25416425/45697168-21247900-bba0-11e8-9d33-6eedcc608687.jpg" alt="TAM-SAM-SOM Approach"></p><p>TAM (Total Addressable Market)은 한국말로 <strong>전체 시장</strong>이다. 제품 및 서비스와 관련된 전체 시장의 규모를 뜻한다.</p><p>예를 들어, 모바일 APP의 경우, 국내 스마트폰 사용자 전체 <strong>4000만명</strong>이 전체 시장 규모일 수 있겠다.</p><p>SAM (Service Available Market)은 한국말로 <strong>유효 시장</strong>이다. </p><p>우리 서비스가 추구하는 비즈니스 모델이 있는 영역만을 타겟팅 한 것인데,</p><p>예를 들어 모바일 헬스케어 스타트업인 경우, 자료를 보니 전체 사용자 중 1/4가 모바일 헬스케어를 이용한다고 나와 있으므로 <strong>1000만명</strong>이다.</p><p>제일 중요한건 SOM (Serviceable Obtainable Market)인데 한국말로 <strong>수익 시장</strong>이다.</p><p>쉽게 말하면 유효 시장 안에서 우리 서비스가 초기에 노릴 수 있는 고객이 몇명인가? 에 대한 답변이다.</p><blockquote><p>누가 너의 초기 서비스에 재화를 지불할 것인가?</p></blockquote><p>위의 시장 규모 추정법에 대해 자세히 알고 싶은 사람은 <a href="https://verticalplatform.kr/archives/5494" target="_blank" rel="noopener">여기</a>를 참고하자.</p><p>나에게 대단히 도움을 많이 주고 계신 로아인벤션랩의 김진영 대표님께서 운영하시는 스타트업 관련 정보 플랫폼이다.</p><p>딱 보면 알겠지만, 결국 <strong>수익 시장을 어떻게 잡느냐</strong>가 초기 스타트업의 성패를 좌우하게 된다.</p><p>그런데, 말이 쉽지 이걸 특정하기는 대단히 어렵다..</p><p>이 때, 괜히 없는 자료 뒤적거리지 말고 사무실 밖으로 나가보면 어떨까. (어짜피 새로운 시도를 할꺼라면 자료가 없을 꺼다)</p><p><img src="https://user-images.githubusercontent.com/25416425/45697776-7f9e2700-bba1-11e8-8ab3-c94d3049883d.jpg" alt="니가 찾는 사실은 사무실에 없으니까 제발 밖에 좀 나가라!"></p><p>이 말씀을 하신 분이 바로 <a href="https://www.slideshare.net/MatthewLee/case-study-51449865" target="_blank" rel="noopener">Lean Startup</a>의 창시자, <strong>Steve Blank</strong> 선생님 되시겠다.</p><p>고객을 특정 지으려면, 먼저 고객을 만나서 <strong>진짜 그들이 겪는 문제</strong>를 들어봐야 한다.</p><p>그러니까 사업계획서에 수익 시장을 적어 넣으려면 고객을 만나야 한다는 거다.</p><p>전화성 대표님께서 말씀해 주신 프로세스가 있다. (그리고 이것이 2차 Mission 발표일에 꼭 들어가야 한다!)</p><ol><li><p>누구한테 팔껀지 가정을 하고, 그 고객한테 찾아간다.</p></li><li><p>내가 설정한 “문제”를 실제로 그들이 심각하게 겪고 있는지 검증한다.</p></li><li><p>내가 설계한 “해결책”을 제시하고, <strong>돈을 지불할 의향이 있는지 물어본다.</strong></p></li></ol><p>2번 단계에서 많은 초기 스타트업 팀은, 그들이 생각하기에 <strong>심각한 문제</strong> 였던 것이 실제로는 별 거 아님을 깨닫는다.</p><p>이 때, 내가 생각하기에 방향이 두가지 정도 있는 것 같은데</p><p>첫 번째는 이들한테 인터뷰를 하면서 <strong>진짜 심각한 문제</strong>를 새로 캐치해 내는 것.</p><p>두 번째는 내가 설정한 <strong>심각한 문제</strong>를 겪을 만한 고객을 다시 물색하는 것.</p><p>두 가지 다 해볼만 하다. 빨리빨리 움직여 봐야 할 것이다.</p><p>또 하나, 3번 단계에서 조금 주의해야 할 사항이 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/45698810-d60c6500-bba3-11e8-8db4-e44e8f324db1.jpg" alt="환하게 웃고 계신 우리동네 음악대장님. 그런데 속마음은 어떨까? 흠"></p><p>고객들은 속마음을 이야기하지 않는다.</p><p>특히, 열심히 자신의 사업에 대해 이야기하는 사람을 앞에 두고 <strong>아 정말 쓸모없네요</strong> 라고 말하는 사람이 과연 몇이나 될까?</p><p>게다가 아는 사람들한테 물어보면 더 그렇다.</p><p>인터뷰도 스킬이다. 고객을 끄덕이는 것은 우리가 원하는 반응이 아니다.</p><p><strong>진짜 매력도를 느끼는 기능이 무엇인지</strong> 캐내야 한다.</p><p>지금 단계에서 고객들이 이야기하는 “괜찮네요” 가 당신한테 그 서비스를 구매하기 위해 돈을 지불하겠다는 것과 다름을 염두에 두자.</p><p><u>사람들의 지갑에서 돈을 꺼내는 건 진짜로 힘든 일이다.</u></p><p>여기서 스티브 잡스 (Steve Jobs) 의 이야기를 꺼내는 사람들이 있을 수 있겠다.</p><p>잡스 형님께서 당당하게 하신 말씀.</p><blockquote><p>나는 아이폰 만들때 시장 조사를 하지 않았다. 고객들은 자신들이 원하는 게 뭔질 모르니까.</p></blockquote><p>요점은 아이폰을 만들 때 자신의 <strong>직관</strong>에 의존하였다는 것인데..</p><p>직관에 의존할 만큼 당신은, 당신이 만들 서비스가 속한 영역에 경험치가 쌓여 있는가?</p><p>스티브 잡스는 컴퓨터를 작게 만드는 데 <u>평생을 미쳐 있었다.</u></p><p>25년동안 쌓은 경험들이 그의 직관을 구성했고, 이는 보통 사람들의 생각을 아득히 뛰어넘은 것이었다.</p><p>실제로 그 사이에 애플은 많은 삽질을 했다. </p><p>그들이 만든 애플 컴퓨터는 소수의 매니아층을 만족시킬 뿐이었고, 과도한 카리스마식 경영을 하다 결국 자신이 만든 회사에서 쫓겨나기까지 하는 수모를 겪은 그다.</p><p>이 정도 경험치로 이루어진 직관에게 시장 조사 결과가 별 건가?</p><p>전화성 대표님깨서 한 마디 하셨다.</p><p><strong>“경험치를 그 정도 쌓은 분야에서 사업을 하던가, 아니면 시간을 가지고 시장 조사를 해”</strong></p><p>실제로 서비스를 오픈에서 시장에 뛰어들면, 수많은 예측하지 못했던 문제들이 튀어나온다.</p><p>그렇다면, 사업 시작 전에 충분히 주의해서 막을 수 있는 문제들은 막아야 하지 않을까?</p><p><strong>치밀하고 날카롭게 사업 하자.</strong></p><p>P.S 전화성 대표님도 <strong>운동</strong>을 대단히 강조하셨다. 사업할려면 인내심이 엄청나게 필요한데 키우는 방법은 오직 운동 뿐이라고. 열심히 하자!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;아닛..!! 저번주에 참여했던 KAIST E5 에서 놀랍게도 상금을 받으면서 2차 미션 대상팀이 되었다.&lt;/p&gt;
&lt;p&gt;아무래도 주제가 좋지 않았나 싶다. 아직 많이 부족하지만..&lt;/p&gt;
&lt;p&gt;아무튼 그래서 오늘은 2차 Mission 인 &lt;strong&gt;Customer Discovery&lt;/strong&gt; 강의를 들으러 KAIST 스타트업 스튜디오 1층으로 모였다.&lt;/p&gt;
&lt;p&gt;저번 비즈니스 모델링은 카카오벤처스 &lt;strong&gt;김기준 상무님&lt;/strong&gt;께서 강연해 주셨고, 이번에는 씨엔티테크 &lt;strong&gt;전화성 대표님&lt;/strong&gt;께서 직접 방문하셨다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/45695810-2c29da00-bb9d-11e8-9742-5bf801e04b03.png&quot; width=&quot;550&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Startup Story" scheme="https://jeongwookie.github.io/newblogtest/categories/Startup-Story/"/>
    
    
      <category term="Startup" scheme="https://jeongwookie.github.io/newblogtest/tags/Startup/"/>
    
      <category term="Business" scheme="https://jeongwookie.github.io/newblogtest/tags/Business/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 카테고리 이름 설정 시 문제</title>
    <link href="https://jeongwookie.github.io/newblogtest/2018/09/13/180913-category-name-problem/"/>
    <id>https://jeongwookie.github.io/newblogtest/2018/09/13/180913-category-name-problem/</id>
    <published>2018-09-12T17:01:42.000Z</published>
    <updated>2019-03-24T08:25:43.464Z</updated>
    
    <content type="html"><![CDATA[<p>새벽에 왠 고생이냐…</p><p>블로그 글을 정리하고 있는데, 갑자기 페이지 로딩이 안됐다.</p><p><img src="https://user-images.githubusercontent.com/25416425/45441549-432e7f00-b6fa-11e8-9625-ffdb1c67e6d6.jpg" width="550"></p><p>짜증을 뒤로 하고, 얼른 해결책부터 찾으려고 하는데 놀라운 점을 발견했다.</p><a id="more"></a><ol><li><p>카테고리 이름이 <strong>Python</strong>, <strong>Growth Hacking</strong>인 곳은 누르면 에러 발생</p></li><li><p>카테고리 이름이 <strong>Diary</strong>, <strong>Github</strong>인 곳은 문제 없이 작동</p></li></ol><p>아니 이게 무슨 상황이란 말인가?</p><p>모두 다 작동이 안된다면 뭔가 directing 문제가 발생했거니와.. 헤더 파일이나 설정 파일을 볼껀데</p><p>이건 되고 저건 안되니 어이가 없더라.</p><p>페이지 관리 도구에 들어가서 페이지 에러를 확인했더니 이런 메세지가 뜬다.</p><blockquote><p>Refused to load the font ‘<url>‘ because it violates the following Content Security Policy directive…</url></p></blockquote><blockquote><p>“default-src ‘none’”. Note that ‘font-src’ was not explicitly set, so ‘default-src’ is used as a fallback.</p></blockquote><p>뭐라고? <strong>Content Security Policy</strong> 라는 걸 어겨서 로딩이 거부되는 거라고?</p><p><img src="https://user-images.githubusercontent.com/25416425/45442114-12e7e000-b6fc-11e8-8fe1-768f1b77cf3d.jpg" alt="아직 아무것도 안했는데 벌써 뭔가를 어겼다고? ㅠㅠ"></p><p>처음에는 폰트가 어쩌구.. 하길래 폰트 로딩이 안됐나 하고 <strong>head.ejs</strong> 파일 살펴보고, <strong>_variables.styl</strong> 이랑 <strong>_config.yml</strong> 설정 파일 계속 들여다보고 이것 저것 고쳐봤는데 안됐다.</p><p>그런데 느낌이 쎄했다. 혹시 Security Policy라 그러니까 카테고리 이름에 hacking이 들어가서 블럭을 당한게 아닐까?</p><p>바로 “Growth Hacking” 이라는 카테고리 이름을  <strong>그로스 해킹</strong> 이라고 바꿨더니.. <strong>됐다?!</strong></p><p>그렇다면 “Python”도 모종의 이유로 블럭을 당했다고 판단, <strong>파이썬</strong>으로 고쳐 적었더니 정상 작동한다.</p><p><strong>결론 : 카테고리 이름에 “Hacking” 이나 “Python” 을 적으면 안된다</strong></p><p>흠.. 정확한 이유는 잘 모르겠다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;새벽에 왠 고생이냐…&lt;/p&gt;
&lt;p&gt;블로그 글을 정리하고 있는데, 갑자기 페이지 로딩이 안됐다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/45441549-432e7f00-b6fa-11e8-9625-ffdb1c67e6d6.jpg&quot; width=&quot;550&quot;&gt;&lt;/p&gt;
&lt;p&gt;짜증을 뒤로 하고, 얼른 해결책부터 찾으려고 하는데 놀라운 점을 발견했다.&lt;/p&gt;
    
    </summary>
    
      <category term="Blog setting" scheme="https://jeongwookie.github.io/newblogtest/categories/Blog-setting/"/>
    
    
      <category term="Github" scheme="https://jeongwookie.github.io/newblogtest/tags/Github/"/>
    
      <category term="Error" scheme="https://jeongwookie.github.io/newblogtest/tags/Error/"/>
    
      <category term="Hexo" scheme="https://jeongwookie.github.io/newblogtest/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Format 함수로 정렬하기</title>
    <link href="https://jeongwookie.github.io/newblogtest/2018/09/11/180911-code-alignment-using-format-function/"/>
    <id>https://jeongwookie.github.io/newblogtest/2018/09/11/180911-code-alignment-using-format-function/</id>
    <published>2018-09-11T14:38:47.000Z</published>
    <updated>2019-03-24T08:27:18.919Z</updated>
    
    <content type="html"><![CDATA[<p>첫 번째 시간에 배운 <strong>Format 함수</strong>로 정렬(Alignment)을 할 수 있다.</p><p>주로 출력물을 보기 좋게 정렬하고 싶을 때 많이 사용한다고 한다.</p><table><thead><tr><th>Code</th><th>Feature</th></tr></thead><tbody><tr><td>{:k&gt;10}</td><td>10칸 공간, <strong>오른쪽 정렬</strong>, 공백을 k로 채우기</td></tr><tr><td>{:k&lt;10}</td><td>10칸 공간, <strong>왼쪽 정렬</strong>, 공백을 k로 채우기</td></tr><tr><td>{:k^10}</td><td>10칸 공간, <strong>가운데 정렬</strong>, 공백을 k로 채우기</td></tr></tbody></table><a id="more"></a><p>아래의 예시 코드를 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 왼쪽 정렬</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:&lt;10&#125; Jeongwook"</span>.format(<span class="string">"Hi"</span>))</span><br><span class="line">Hi         Jeongwook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 오른쪽 정렬</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:&gt;10&#125; Jeongwook"</span>.format(<span class="string">"Hi"</span>))</span><br><span class="line">        Hi Jeongwook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10칸 공간, 2칸에 Hi 넣고 나머지는 공백, 가운데 정렬</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:^10&#125; Jeongwook"</span>.format(<span class="string">"Hi"</span>))</span><br><span class="line">    Hi     Jeongwook</span><br></pre></td></tr></table></figure><p>&lt;는 왼쪽 정렬, &gt;은 오른쪽 정렬, ^은 가운데 정렬임을 기억하자.</p><p>콜론(:) 바로 뒤에 채우고 싶은 문자나 숫자를 입력하면 된다.</p><p>아래와 같이 print 함수로 출력할때 예쁘게 구분하기 위해 사용한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20칸 공간, 5칸에 Hello 넣고 나머지는 =으로 채움, 가운데 정렬</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"&#123;:=^20&#125;"</span>.format(<span class="string">"Hello"</span>))</span><br><span class="line">=======Hello========</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;첫 번째 시간에 배운 &lt;strong&gt;Format 함수&lt;/strong&gt;로 정렬(Alignment)을 할 수 있다.&lt;/p&gt;
&lt;p&gt;주로 출력물을 보기 좋게 정렬하고 싶을 때 많이 사용한다고 한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Feature&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;{:k&amp;gt;10}&lt;/td&gt;
&lt;td&gt;10칸 공간, &lt;strong&gt;오른쪽 정렬&lt;/strong&gt;, 공백을 k로 채우기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{:k&amp;lt;10}&lt;/td&gt;
&lt;td&gt;10칸 공간, &lt;strong&gt;왼쪽 정렬&lt;/strong&gt;, 공백을 k로 채우기&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{:k^10}&lt;/td&gt;
&lt;td&gt;10칸 공간, &lt;strong&gt;가운데 정렬&lt;/strong&gt;, 공백을 k로 채우기&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/newblogtest/tags/Python/"/>
    
      <category term="KAIST IT Program" scheme="https://jeongwookie.github.io/newblogtest/tags/KAIST-IT-Program/"/>
    
  </entry>
  
  <entry>
    <title>문자열 자료형 다루기</title>
    <link href="https://jeongwookie.github.io/newblogtest/2018/09/10/180910-common-string-operation/"/>
    <id>https://jeongwookie.github.io/newblogtest/2018/09/10/180910-common-string-operation/</id>
    <published>2018-09-10T14:30:06.000Z</published>
    <updated>2019-03-24T08:14:04.894Z</updated>
    
    <content type="html"><![CDATA[<p>첫번째 강의 시간에 배운 내용 중 주목해야 할 점은 <strong>format</strong>의 쓰임이었다.</p><p>예전에 C로 코딩할때는 %d, %f 등을 잘 찍어줘야 하는데, 파이썬은 그런게 없어도 잘되네?</p><p>기본적인 포맷은 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123;&#125; &#123;&#125;'</span>.format(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br></pre></td></tr></table></figure><p>이렇게 치면 결과값이 “one two”로 나온다. (string)</p><p>내가 앞에서 순서를 지정할 수도 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123;1&#125; &#123;0&#125;'</span>.format(<span class="string">'one'</span>, <span class="string">'two'</span>)</span><br></pre></td></tr></table></figure><p>결과값은 “two one” 이다.</p><p>자세한 내용은 <a href="https://pyformat.info/" target="_blank" rel="noopener">PyFormat</a>에서 확인할 수 있다.</p><p>이외에도 주로 <strong>문자열 자료형</strong>에 대해서 다루었다. 내용을 간단히 열거하면 아래와 같다.</p><a id="more"></a><h4 id="문자열-더하기-및-곱하기"><a href="#문자열-더하기-및-곱하기" class="headerlink" title="문자열 더하기 및 곱하기"></a>문자열 더하기 및 곱하기</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"I love "</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"Python!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a+b)</span><br><span class="line"><span class="string">"I love Python!"</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"="</span> * <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Python is god"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"="</span> * <span class="number">20</span>)</span><br><span class="line">====================</span><br><span class="line"><span class="string">"Python is god"</span></span><br><span class="line">====================</span><br></pre></td></tr></table></figure><h4 id="문자열-인덱싱"><a href="#문자열-인덱싱" class="headerlink" title="문자열 인덱싱"></a><strong>문자열 인덱싱</strong></h4><p>문자열 인덱싱이란, 말그대로 문자열에서 문자들에게 순서를 숫자로 매기는(indexing) 것이다.<br><strong>“파이썬은 0부터 숫자를 센다”</strong> 라는 사실만 주의하자.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">"Python"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">0</span>]</span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">3</span>]</span><br><span class="line"><span class="string">'h'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'n'</span></span><br></pre></td></tr></table></figure></p><h4 id="문자열-슬라이싱"><a href="#문자열-슬라이싱" class="headerlink" title="문자열 슬라이싱"></a><strong>문자열 슬라이싱</strong></h4><p>문자열 슬라이싱이란, 주어진 문자열을 자르는 (slicing) 것이다. 내가 원하는 만큼 범위를 지정하면 딱 그만큼 잘라서 준다. 단, 범위를 지정할 때 <strong>끝은 포함하지 않음</strong>에 주의하자.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>string = <span class="string">"Python is king"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">0</span>:<span class="number">7</span>]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[<span class="number">7</span>:]</span><br><span class="line"><span class="string">' is king'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>string[:]</span><br><span class="line"><span class="string">'Python is king'</span></span><br></pre></td></tr></table></figure></p><p>문자열 슬라이싱은 주어진 문자열을 수정하고 싶을 때 유용하게 사용할 수 있다.<br>문자열의 요소값은 바꿀 수 있는 값이 아니기 때문에 (immutable: 불변의) 문자열 슬라이싱 후 더하는 방법을 사용한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 예시: "Pithon" 을 "Python"으로 바꾸고 싶다!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"Pithon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">1</span>]</span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:]</span><br><span class="line"><span class="string">'thon'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">1</span>] + <span class="string">'y'</span> + a[<span class="number">2</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure></p><h4 id="문자열-관련-함수들"><a href="#문자열-관련-함수들" class="headerlink" title="문자열 관련 함수들"></a><strong>문자열 관련 함수들</strong></h4><p>자주 쓰이는 함수는, </p><ul><li><a href="https://www.programiz.com/python-programming/methods/string/find" target="_blank" rel="noopener">find</a> (인덱스 알려주기)</li><li><a href="https://www.programiz.com/python-programming/methods/string/strip" target="_blank" rel="noopener">strip</a> (공백 지우기)</li><li><a href="https://www.programiz.com/python-programming/methods/string/replace" target="_blank" rel="noopener">replace</a> (문자열 바꾸기)</li><li><a href="https://www.programiz.com/python-programming/methods/string/split" target="_blank" rel="noopener">split</a> (문자열 나누기)</li></ul><p>등이 있다.</p><p>자세한 내용은 <a href="https://wikidocs.net/13#_11" target="_blank" rel="noopener">점프투 파이썬 위키</a>를 참고하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;첫번째 강의 시간에 배운 내용 중 주목해야 할 점은 &lt;strong&gt;format&lt;/strong&gt;의 쓰임이었다.&lt;/p&gt;
&lt;p&gt;예전에 C로 코딩할때는 %d, %f 등을 잘 찍어줘야 하는데, 파이썬은 그런게 없어도 잘되네?&lt;/p&gt;
&lt;p&gt;기본적인 포맷은 아래와 같다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&amp;#123;&amp;#125; &amp;#123;&amp;#125;&#39;&lt;/span&gt;.format(&lt;span class=&quot;string&quot;&gt;&#39;one&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;two&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;이렇게 치면 결과값이 “one two”로 나온다. (string)&lt;/p&gt;
&lt;p&gt;내가 앞에서 순서를 지정할 수도 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&amp;#123;1&amp;#125; &amp;#123;0&amp;#125;&#39;&lt;/span&gt;.format(&lt;span class=&quot;string&quot;&gt;&#39;one&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;two&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;결과값은 “two one” 이다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href=&quot;https://pyformat.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PyFormat&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;이외에도 주로 &lt;strong&gt;문자열 자료형&lt;/strong&gt;에 대해서 다루었다. 내용을 간단히 열거하면 아래와 같다.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://jeongwookie.github.io/newblogtest/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/newblogtest/tags/Python/"/>
    
      <category term="KAIST IT Program" scheme="https://jeongwookie.github.io/newblogtest/tags/KAIST-IT-Program/"/>
    
  </entry>
  
  <entry>
    <title>중요한 미팅을 다녀와서</title>
    <link href="https://jeongwookie.github.io/newblogtest/2018/03/27/180327-after-meeting/"/>
    <id>https://jeongwookie.github.io/newblogtest/2018/03/27/180327-after-meeting/</id>
    <published>2018-03-27T13:10:11.000Z</published>
    <updated>2019-03-24T07:52:51.489Z</updated>
    
    <content type="html"><![CDATA[<p>어제는 밤을 꼬박 새고 아침 일찍 강남에 도착했다.</p><p>11시 선릉 미팅에 점심 식사 하고, 4시에 을지로 미팅, 그리고 저녁 7시까지 대전 복귀해서 수업 들어가는 매우 강행군 스케줄;;</p><p>그래도 오랜만에 움직이는 거라 정신 바짝 차리고 임했다.</p><p>여러 가지 이슈가 새로 생겨서 앞으로 더 바빠질 것 같다.</p><p>나름 깨달은 사실이 있다면,</p><ol><li><p>내가 여러 사람 앞에서 피칭하는 것은 자신이 있어도 1:1로 설명은 잘 못한다는 것</p></li><li><p>짧게 보고해야 하는 자리인데도 미괄식으로 자꾸 말을 한다는 것</p></li></ol><p>두 가지 모두 앞으로 고쳐나가야겠다…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어제는 밤을 꼬박 새고 아침 일찍 강남에 도착했다.&lt;/p&gt;
&lt;p&gt;11시 선릉 미팅에 점심 식사 하고, 4시에 을지로 미팅, 그리고 저녁 7시까지 대전 복귀해서 수업 들어가는 매우 강행군 스케줄;;&lt;/p&gt;
&lt;p&gt;그래도 오랜만에 움직이는 거라 정신 
      
    
    </summary>
    
      <category term="Diary" scheme="https://jeongwookie.github.io/newblogtest/categories/Diary/"/>
    
    
      <category term="Daily life" scheme="https://jeongwookie.github.io/newblogtest/tags/Daily-life/"/>
    
  </entry>
  
</feed>
