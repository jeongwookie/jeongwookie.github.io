<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JW&#39;s Blog</title>
  
  <subtitle>Make stuff people want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeongwookie.github.io/"/>
  <updated>2021-12-20T09:18:56.774Z</updated>
  <id>https://jeongwookie.github.io/</id>
  
  <author>
    <name>Jeongwook, Kim</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS공부 - 스케쥴링 정책</title>
    <link href="https://jeongwookie.github.io/2021/12/20/computerscience/operatingsystem/6-scheduling-policy/"/>
    <id>https://jeongwookie.github.io/2021/12/20/computerscience/operatingsystem/6-scheduling-policy/</id>
    <published>2021-12-20T07:45:46.000Z</published>
    <updated>2021-12-20T09:18:56.774Z</updated>
    
    <content type="html"><![CDATA[<h3 id="몇-가지-가정"><a href="#몇-가지-가정" class="headerlink" title="몇 가지 가정"></a>몇 가지 가정</h3><p>프로세스가 동작하는 일련의 행위를 워크로드 (workload) 라고 한다. 프로세스 스케쥴링을 이해하기 위해, 먼저 현실과는 동떨어진 워크로드를 가정하고 해당 가정들을 하나하나 제거할 수 있는 스케쥴링 정책들을 알아볼 것이다.</p><ul><li>모든 작업은 같은 시간 동안 실행 된다.</li><li>모든 작업은 동시에 도착한다.</li><li>작업은 일단 시작하면 최종적으로 종료될 때 까지 실행된다.</li><li>모든 작업은 CPU만 사용하며, 입출력을 수행하지 않는다.</li><li>각 작업의 실행 시간은 사전에 알려져 있다.</li></ul><a id="more"></a><h3 id="평가-항목"><a href="#평가-항목" class="headerlink" title="평가 항목"></a>평가 항목</h3><p>스케쥴링 정책의 평가를 위해서는 스케쥴링 평가 항목 (scheduling metric)을 결정해야 한다. 책에서 언급한 몇가지 대표적인 평가 항목에 대해서 알아보자. 각 항목들은 성능 측면 혹은 공정성 측면에서 스케쥴링 정책을 평가한다.</p><h4 id="반환-시간"><a href="#반환-시간" class="headerlink" title="반환 시간"></a>반환 시간</h4><p>반환 시간 (turnaround time)은 <u>작업이 완료된 시간에서 작업이 도착한 시간을 뺀 시간</u>이다. 즉, 어떤 프로세스가 완료될 때 까지 걸린 시간이라고 이해하면 된다. 철저히 성능 측면에서 평가하는 지표이다.</p><h4 id="응답-시간"><a href="#응답-시간" class="headerlink" title="응답 시간"></a>응답 시간</h4><p>응답 시간 (response time)은 <u>작업이 처음 실행되는 시간에서 작업이 도착한 시간을 뺀 시간</u>이다. 예를 들어 1번 프로세스가 2초에 도착하여 대기 후 6초에 처음으로 실행 되었다면 응답 시간은 4초가 된다. 시스템이 얼마나 상호작용을 잘 하는가를 평가하는 지표라고 할 수 있겠다.</p><h4 id="공정성"><a href="#공정성" class="headerlink" title="공정성"></a>공정성</h4><p>공정성 (fairness)은 <u>여러 개의 작업들의 완료 시간이 얼마나 비슷한지 비교하는 지표</u>이다. 예를 들어 1번 프로세스는 1초만에 완료되었는데 2번 프로세스는 10초만에 완료되었다면, 이는 공정성이 좋지 못한 스케쥴러라고 할 수 있다. 성능과 공정성은 서로 상충하는 지표이다. 전체 시스템의 성능을 극대화 하기 위해 몇몇 작업들에 대해서 기회를 주지 않는다면 이는 공정성이 악화되는 것이다.</p><h3 id="선입선출-알고리즘"><a href="#선입선출-알고리즘" class="headerlink" title="선입선출 알고리즘"></a>선입선출 알고리즘</h3><p>가장 기본적인 알고리즘으로, 선입선출 (First In First Out) 혹은 선도착선처리 (First Come First Served, FCFS) 스케쥴링 이라고 부른다. 자료구조 Queue와 같은 원리로 동작한다.</p><p><img src="https://user-images.githubusercontent.com/25416425/146739771-ff093d78-1c64-4a60-83a4-7c9d8a090be0.png" alt="image"></p><p>예를 들어서 세 개의 작업 A,B,C가 거의 동시에, 그러나 알파벳 순서대로 도착했다고 가정하자. 각 작업은 10초동안 실행된다. FCFS 알고리즘으로 해당 작업들을 스케쥴링하면 위와 같은 그림처럼 실행된다. 가장 먼저 도착한 A가 10초동안 실행되고 종료, 그다음이 B로 10초동안 실행되고 종료, 그리고 마지막으로 C가 10초동안 실행되고 종료된다. 이제 각 작업에 대하여 반환 시간과 응답 시간을 계산해 보자.</p><ul><li>A는 0초에 도착해서 10초에 완료되었다. 그러므로 반환 시간은 10초, 응답 시간은 0초이다.</li><li>B는 0초에 도착해서 10초에 시작되었으며, 20초에 완료되었다. 그러므로 반환 시간은 20초, 응답 시간은 10초이다.</li><li>C는 0초에 도착해서 20초에 시작되었으며, 30초에 완료되었다. 그러므로 반환 시간은 30초, 응답 시간은 20초이다.</li><li>평균 반환 시간은 20초이고, 평균 응답 시간은 10초이다.</li></ul><p>FCFS 알고리즘으로 계산한 결과를 보니 꽤 나쁘지 않아 보인다. 흠… 이제 제일 처음 가정하였던 작업 실행 시간에 대한 부분을 제거해서 문제점을 알아보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/146740877-41afc472-170d-4151-9f7f-ac73a83f630c.png" alt="image"></p><p>위의 예시는 앞선 예시와 대부분의 조건이 동일하나, 작업 A가 100초동안 실행되는 것만 다르다. 모든 작업이 같은 시간동안 실행된다는 가정을 제거한 것이다. 이때 앞선 예시처럼 각 작업에 대해 반환 시간과 응답 시간을 구해 보자.</p><ul><li>A는 0초에 도착해서 100초에 완료되었다. 그러므로 반환 시간은 100초, 응답 시간은 0초이다.</li><li>B는 0초에 도착해서 100초에 시작되었으며, 110초에 완료되었다. 그러므로 반환 시간은 110초, 응답 시간은 100초이다.</li><li>C는 0초에 도착해서 110초에 시작되었으며, 120초에 완료되었다. 그러므로 반환 시간은 120초, 응답 시간은 110초이다.</li><li>평균 반환 시간은 <strong>110초</strong>이고, 평균 응답 시간은 70초이다.</li></ul><p>이제 FCFS 알고리즘의 단점이 명확하게 보인다. 위의 예시처럼 시간이 많이 필요한 작업이 먼저 수행되면, 빨리 끝날 수 있었던 작업들이 한없이 기다린다. 그래서 결과적으로 평균 반환 시간이 심각한 수준으로 증가한다. 이러한 현상을 <strong>convoy effect</strong>라고 한다. 유튜브에서 해당 현상을 설명한 영상을 보았는데, 일명 똥차 효과라고 하더라. 똥차가 앞에서 길막고 있으면 뒤에 아무리 슈퍼카가 있어도 못지나간다는..ㅋㅋㅋ 대형마트에서도 이런 현상이 벌어진다. 나는 생수 한병 살려고 하는데 내 앞에 한 3일치 식량을 사는 분이 계시다면 ㅠㅠ 한병은 금방 계산해서 나갈 수 있는건데 계속 기다려야 하기에 효율성에서 문제가 생기겠지?</p><h3 id="최단-우선-작업-알고리즘"><a href="#최단-우선-작업-알고리즘" class="headerlink" title="최단 우선 작업 알고리즘"></a>최단 우선 작업 알고리즘</h3><p>최단 우선 작업 (Shortest Job First, SJF) 알고리즘은 위 convoy effect를 간단하게 해결하는 알고리즘이다.<br>계속 작성할 계획…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;몇-가지-가정&quot;&gt;&lt;a href=&quot;#몇-가지-가정&quot; class=&quot;headerlink&quot; title=&quot;몇 가지 가정&quot;&gt;&lt;/a&gt;몇 가지 가정&lt;/h3&gt;&lt;p&gt;프로세스가 동작하는 일련의 행위를 워크로드 (workload) 라고 한다. 프로세스 스케쥴링을 이해하기 위해, 먼저 현실과는 동떨어진 워크로드를 가정하고 해당 가정들을 하나하나 제거할 수 있는 스케쥴링 정책들을 알아볼 것이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 작업은 같은 시간 동안 실행 된다.&lt;/li&gt;
&lt;li&gt;모든 작업은 동시에 도착한다.&lt;/li&gt;
&lt;li&gt;작업은 일단 시작하면 최종적으로 종료될 때 까지 실행된다.&lt;/li&gt;
&lt;li&gt;모든 작업은 CPU만 사용하며, 입출력을 수행하지 않는다.&lt;/li&gt;
&lt;li&gt;각 작업의 실행 시간은 사전에 알려져 있다.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
      <category term="process" scheme="https://jeongwookie.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>OS공부 - 제한적 직접 실행</title>
    <link href="https://jeongwookie.github.io/2021/12/15/computerscience/operatingsystem/5-limited-direct-execution/"/>
    <id>https://jeongwookie.github.io/2021/12/15/computerscience/operatingsystem/5-limited-direct-execution/</id>
    <published>2021-12-15T08:47:11.000Z</published>
    <updated>2021-12-16T08:59:35.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>본 포스팅부터 Remzi 교수님의 <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/" rel="external nofollow noopener noreferrer" target="_blank">Operating Systems: Three Easy Pieces</a>로 교재를 갈아탑니다.</em></p></blockquote><h2 id="Limited-Direct-Execution"><a href="#Limited-Direct-Execution" class="headerlink" title="Limited Direct Execution"></a>Limited Direct Execution</h2><p>cpu를 가상화 하기 위해, 우리는 시분할 (time-sharing) 아이디어를 도입했다. 한 프로세스를 잠시 동안 실행하고, 다른 프로세스를 또 잠깐 실행하고, 이런식으로 계속해서 잠깐씩 실행시키면 된다. 그런데 여기에는 두가지 문제점이 있다.</p><ul><li>성능 저하 : 계속 process를 바꾸는 것은 시스템에 과중한 overhead를 줄 수 있어, 이것은 성능 저하로 이어진다.</li><li>제어 문제 : cpu에 대한 제어를 유지하면서 process를 효율적으로 실행해야 한다. 그렇지 않으면 한 프로세스가 영원히 실행되거나, 접근해서는 안되는 정보에 접근할 수 있다.</li></ul><p>어떻게 하면 cpu 가상화를 성능과 제어를 유지하면서 구현할 수 있을까? 본 포스트에서는 위의 두 문제를 해결하는 기법인 <strong>제한적 직접 실행 (Limited Direct Execution)</strong>에 대해서 알아볼 것이다.</p><a id="more"></a><h2 id="기본-원리"><a href="#기본-원리" class="headerlink" title="기본 원리"></a>기본 원리</h2><p>Limited 라는 단어를 제외한 Direct Execution은 말 그대로 프로그램을 cpu상에서 직접 실행하는 것을 의미한다.<br>운영체제는 PCB에 해당하는 메모리에 정보들을 탑재하고, main()을 실행한다. 이 때, 프로그램은 한번 수행되면 종료될 때 까지 수행된다. 그러므로, 앞서 언급한 cpu 가상화를 구현할 수가 없다..!! 한번 실행된 프로세스에 대해서 제어권이 없으며, 다른 프로세스를 번갈아가면서 수행하는 time-sharing도 할 수 없다 ㅠㅠ<br>그러므로, 프로그램 실행에 제한을 두지 않으면 (limited) 안된다는 결론에 도달했다. 어떤 식으로 제한을 두어서 위의 문제점들을 해결할 수 있을지 알아보자.</p><h2 id="문제점-1-제한된-연산"><a href="#문제점-1-제한된-연산" class="headerlink" title="문제점 1: 제한된 연산"></a>문제점 1: 제한된 연산</h2><p>직접 실행의 장점은 빠르게 실행된다는 것이다. 그러나 프로그램 실행 도중에 disk에 I/O 요청을 한다거나 Memory를 더 할당받고 싶을 때 이를 해결할 수 없다. 또한, 프로세스가 악의적인 코드를 실행하더라도 운영체제는 해당 프로세스에 cpu 제어권을 넘겨줬기 때문에 이를 막을 방법이 없다.. 이를 어떻게 해결하면 좋을까?</p><p>그냥 프로세스가 하고싶은 대로 하라고 방치하면, 위의 문제 상황 중 일부는 해결할 수 있을 것이다.. 그러나 프로세스의 권한을 제한할 수 없어 disk에 대한 보호 기능이 완전히 상실되게 된다.</p><p>이러한 문제 때문에 실제로 도입된 방법은 위의 방법이 아니다. 바로 <strong>사용자 모드 (user mode)</strong>와 <strong>커널 모드 (kernel mode)로</strong> 실행 모드를 구별하는 것이다. 사용자 모드에서는 할 수 있는 일이 제한되어 있다. 예를 들어 응용 프로그램은 하드웨어 자원에 대한 접근 권한이 제한되어 있고, 이를 넘어서는 코드가 실행된다면 프로세스는 곧바로 예외를 발생시켜 운영체제에게 해당 사실을 알려준다. 운영체제는 해당 프로세스를 제거해버린다.<br>커널 모드에서는 운영체제의 중요한 코드들이 실행된다. 컴퓨터의 모든 자원에 대한 접근 권한을 가지고 있다. 그래서 해당 모드에서는 원하는 모든 작업을 수행할 수 있다.</p><p>만약 사용자 프로세스가 disk I/O와 같은 특권 명령어를 실행하고 싶을때는 어떻게 하면 될까? 이러한 제한 작업의 실행을 허용하기 위해 <strong>시스템 콜 (System call)</strong>이 도입되었다. 시스템 콜은 유저 모드 프로세스에게 커널 모드에서 수행가능한 작업을 수행할 수 있도록 OS가 제공하는 API라고 이해하면 된다. 시스템 콜이 실행되면, <code>trap</code>이라는 특수 명령어가 실행 되고 이는 모드를 커널 모드로 전환한다. 그리고 커널 모드에서 유저 프로세스가 요청한 특정한 작업을 처리한다. 이후 운영체제는 <code>return-from-trap</code>이라는 특수 명령어를 호출하여 다시 모드를 원래 모드인 유저 모드로 전환한다.</p><p><code>trap</code> 명령어가 실행될때를 좀 더 자세하게 알아보자. 해당 명령이 수행되면, 프로세스는 program counter, flags, register 정보 등을 각 프로세스의 커널 스택에 저장한다. 나중에 다시 유저 모드로 돌아왔을 때 프로세스를 제대로 리턴해야 하기 때문이다. 커널 모드에서의 작업이 마무리되면 <code>return-from-trap</code>가 호출되는데, 이때 아까 커널 스택에 저장해둔 정보들을 pop 하여 모두 제거한다.</p><blockquote><p><em>Q. trap 명령어가 실행되면, 운영체제의 어떤 코드를 실행할지 어떻게 알까?</em><br><em>운영체제가 trap을 처리하기 위해서 <strong>trap table</strong>을 사용한다. 이 테이블은 부팅 시에 초기화가 이루어지며, 소프트웨어적 사건들을 처리하기 위한 함수 (trap handler) 들이 들어 있다. 각 함수에는 시스템 콜 넘버 (system call number)라는 번호가 정의되어 있고, 운영체제만 해당 위치를 기억 하고 있다. 이제 유저 프로세스가 trap 명령어를 호출하면, 전달 받은 시스템 콜 번호를 확인한 후 유효한 경우 이를 테이블에서 검색 후 실행한다. (사용자 프로그램은 시스템 콜의 위치를 모른다! 일종의 보안 기법이다.)</em></p></blockquote><p><img src="https://user-images.githubusercontent.com/25416425/146164998-89dc44a9-81b0-4ff8-9fdc-80c6a20791bd.png" width="400"></p><h2 id="문제점-2-프로세스-간-전환"><a href="#문제점-2-프로세스-간-전환" class="headerlink" title="문제점 2: 프로세스 간 전환"></a>문제점 2: 프로세스 간 전환</h2><p>직접 실행의 두번째 문제점은 프로세스 간 전환 방식에 있다. 프로세스의 전환이란 실행 중인 프로세스를 멈추고 다른 프로세스를 실행하는 것이다. 우리는 이러한 전환을 통해 time-sharing을 구현할 수 있는데, <u>운영체제는 어떻게 cpu를 확득하여 프로세스를 전환할 수 있을까?</u></p><h3 id="협조-방식"><a href="#협조-방식" class="headerlink" title="협조 방식"></a>협조 방식</h3><p>첫 번째 방법은 서로 협력하는 방식 (cooperative)으로, 착한 프로세스만 있다고 가정한다. 각 프로세스가 비정상적인 행동은 하지 않고, 오래 연산할 프로세스는 다른 프로세스들이 cpu를 사용할 수 있도록 주기적으로 cpu를 반납할 것이라고 믿는다. 프로세스가 cpu를 반납할 때에는 시스템 콜을 활용한다. 프로세스 실행 도중 시스템 콜을 적절히 활용하여 서로 협조적으로 cpu를 사용하는 방식인 것이다. 만약 프로세스 내에서 0으로 나눈다던지 하는 비정상적인 연산이 발생하면 trap이 일어나 운영체제로 주도권이 넘어온다.</p><p>그런데, 잘 생각해보면 위 방식은 매우 수동적이다. 운영체제는 프로세스가 시스템 콜을 호출하거나 에러가 발생할때 까지 계속 기다릴 수 밖에 없다. 프로세스가 무한루프에 빠져서 시스템 콜을 하지 못하는 상황이면.. 망한다 ㅠ</p><h3 id="비협조-방식"><a href="#비협조-방식" class="headerlink" title="비협조 방식"></a>비협조 방식</h3><p>프로세스가 시스템 콜을 하지 않는 경우, 하드웨어를 강제로 재부팅 하는 방법이 있다. 좋은 방법이긴 한데 프로세스가 너무 길게 cpu를 점유하고 있다고 재부팅을 할 수는 없지 않은가? 다른 방법은 무엇이 있을까?</p><p>시스템 콜의 호출이 없어도 운영체제가 제어권을 할당하는 방법은 바로 특정 시간마다 강제로 interrupt를 걸어버리는 것이다. (이러한 방법을 <strong>timer interrupt</strong> 라고 한다.) interrupt가 발생하면 운영체제는 수행 중인 프로세스를 중단하고 interrupt handler을 실행한다. 이 핸들러는 운영체제의 일부분이기 때문에 interrupt를 처리하는 과정에서 자연스럽게 제어권이 운영체제로 넘어가게 된다. 제어권을 획득한 운영체제는 그대로 기존의 프로세스를 실행할 수도 있고, 다른 프로세스를 실행할 수도 있을 것이다. 타이머가 interrupt를 주기적으로 발생시키기 때문에, 혹시나 비정상적인 프로그램이 동작하더라도 끌 수 있는 기회를 매 주기마다 가지게 된다.</p><h2 id="문맥의-저장과-복원"><a href="#문맥의-저장과-복원" class="headerlink" title="문맥의 저장과 복원"></a>문맥의 저장과 복원</h2><p>시스템 콜을 하던 반강제적으로 타이머 인터럽트를 통해 제어권을 가져오던 운영체제가 제어권을 획득하면 이제 중요한 결정을 내려야 한다. 현재 실행중이었던 프로세스를 계속 실행할 것인지, 아니면 다른 프로세스로 전환할 것인지를 말이다. 이 결정은 운영 체제의 스케쥴러 (scheduler)가 내리는데 이후에 자세히 공부할 것이다.</p><p>일단 현재 프로세스를 중단하고 다른 프로세스로 전환하기로 결정했다고 하자. 이 때, 운영체제는 <strong>문맥 교환 (context switch)</strong>이라 불리는 코드를 실행한다. 현재 실행 중인 프로세스의 레지스터 값 (문맥) 들을 커널 스택에 저장하고, 새로 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이다. 그렇게 되면 <code>return-from-trap</code> 명령어가 실행될 때 현재 사용중인 프로세스로 리턴이 아니라, 레지스터 값이 복원된 다른 프로세스로 리턴된다.</p><p><img src="https://user-images.githubusercontent.com/25416425/146329567-ee4bd637-339c-49fd-a48d-99d358de4b9b.png" width="500"></p><blockquote><p><em>Q. 문맥 교환 시 레지스터의 저장/복원에 대해서 조금 더 자세하게 알고 싶어!</em><br><em>문맥 교환 시 서로 다른 두 가지 종류의 레지스터의 저장 및 복원이 발생함. 첫 번째는 타이머 인터럽트가 발생했을 때인데, 사용 중인 프로세스의 레지스터가 하드웨어에 의해 저장되고, 저장 장소로는 해당 프로세스의 커널 스택이 사용됨. 두 번째는 운영체제가 문맥 교환을 결정했을 때 발생하는데, 이 경우 커널 레지스터는 운영체제에 의해 해당 프로세스의 PCB에 저장됨.</em><br><em>복원 시에도 먼저 PCB에 저장되어 있는 레지스터를 복원하고, 이후 전환되는 프로세스의 커널 스택에 해당 레지스터가 복원됨.</em></p></blockquote><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>제한적 직접 실행 방식은 마치 아기 보호 장치와 같음. cpu 사용에 대한 안전 장치를 제공하는 것임</li><li>사용자 모드와 커널 모드로 구분하여, 커널 모드에서만 모든 명령어가 실행될 수 있도록 함</li><li>읿반적인 응용 프로그램은 사용자 모드에서 실행되며, 시스템 콜을 사용해여 커널로 trap해서 운영체제의 서비스를 요청함</li><li>프로세스 간 전환을 비협조적 방식으로 수행할 경우, 이를 위한 방법 중 하나가 주기적으로 타이머 인터럽트를 발생시키는 것임 </li><li>문맥 전환은 현재 프로세스에서 다른 프로세스로 전환하는 것을 의미함</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;본 포스팅부터 Remzi 교수님의 &lt;a href=&quot;https://pages.cs.wisc.edu/~remzi/OSTEP/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Operating Systems: Three Easy Pieces&lt;/a&gt;로 교재를 갈아탑니다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Limited-Direct-Execution&quot;&gt;&lt;a href=&quot;#Limited-Direct-Execution&quot; class=&quot;headerlink&quot; title=&quot;Limited Direct Execution&quot;&gt;&lt;/a&gt;Limited Direct Execution&lt;/h2&gt;&lt;p&gt;cpu를 가상화 하기 위해, 우리는 시분할 (time-sharing) 아이디어를 도입했다. 한 프로세스를 잠시 동안 실행하고, 다른 프로세스를 또 잠깐 실행하고, 이런식으로 계속해서 잠깐씩 실행시키면 된다. 그런데 여기에는 두가지 문제점이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;성능 저하 : 계속 process를 바꾸는 것은 시스템에 과중한 overhead를 줄 수 있어, 이것은 성능 저하로 이어진다.&lt;/li&gt;
&lt;li&gt;제어 문제 : cpu에 대한 제어를 유지하면서 process를 효율적으로 실행해야 한다. 그렇지 않으면 한 프로세스가 영원히 실행되거나, 접근해서는 안되는 정보에 접근할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어떻게 하면 cpu 가상화를 성능과 제어를 유지하면서 구현할 수 있을까? 본 포스트에서는 위의 두 문제를 해결하는 기법인 &lt;strong&gt;제한적 직접 실행 (Limited Direct Execution)&lt;/strong&gt;에 대해서 알아볼 것이다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
      <category term="process" scheme="https://jeongwookie.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>OS공부 - 프로세스 스케쥴링</title>
    <link href="https://jeongwookie.github.io/2021/12/13/computerscience/operatingsystem/4-process-scheduling/"/>
    <id>https://jeongwookie.github.io/2021/12/13/computerscience/operatingsystem/4-process-scheduling/</id>
    <published>2021-12-13T08:20:41.000Z</published>
    <updated>2021-12-14T09:00:23.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로세스-스케쥴링"><a href="#프로세스-스케쥴링" class="headerlink" title="프로세스 스케쥴링"></a>프로세스 스케쥴링</h2><p>우리는 일반적으로 많은 프로그램을 동시에 사용하고 있다.<br>실행 중인 프로그램을 프로세스라고 하기에, 많은 프로세스가 동시에 동작하고 있다고 생각할 수 있겠다.<br>하지만, 가장 기본적인 cpu core 구성이라고 가정하였을 때 하나의 프로세스가 cpu를 점유하고 있으면 다른 프로세스는 이를 기다려야 한다.<br>그렇다면, 누가 먼저 실행되고 누가 나중에 실행되는가? 나중에 실행되는 프로세스는 이전 프로세스가 종료될 때 까지 계속 기다려야 하는가? 이런 의문점들이 생긴다.<br>또한, 우리는 cpu를 최대한 효율적으로 사용함과 동시에 위에 언급한 대로 하나의 프로그램이 아니라 여러 개의 프로그램과 동시에 상호작용을 하고 싶다. 유튜브 보면서 카카오톡도 하고, 게임도 해야할 것 아닌가? 이러한 상황에 직면하면, 우리는 프로세스를 스케쥴링 (Process Scheduling) 하는 것이 얼마나 중요한 것인지 깨닫게 된다.<br>이번 포스트에서는 아직 multiprogramming까지는 다루지 않고, 프로세스들 간의 교환이 어떻게 이루어지는지를 먼저 살펴본다.</p><a id="more"></a><h3 id="Scheduling-Queue"><a href="#Scheduling-Queue" class="headerlink" title="Scheduling Queue"></a>Scheduling Queue</h3><p>프로세스가 시작되고 초기화가 완료되면, 해당 프로세스는 먼저 <code>ready queue</code>에 진입하여 cpu core을 점유할 때 까지 (running 상태) 기다린다. 또한 어떤 특정 이벤트 (ex. I/O interrupt)가 발생하기를 기다리는 프로세스의 경우, 이들을 <code>wait queue</code>에 위치시키고 기다리게 한다. 이러한 큐들은 프로세스 컨트롤 블록 (PCB)의 <strong>Linked List</strong>로 구현할 수 있겠다.</p><p><img src="https://user-images.githubusercontent.com/25416425/145779168-7f95a926-aacc-4caa-9cb9-d92dd8e83304.png" alt="image"></p><p>제일 위의 ready queue를 살펴보면, PCB 7번이 먼저 실행되고 이후 PCB 2번이 실행됨을 알 수 있다.<br>아래 네 개의 linked list는 각각이 device와 연결된 wait queue인데, disk I/O를 기다리는 PCB 3번, 14번, 6번이 차례대로 대기하고 있음을 알 수 있다. 바로 아래에는 terminal I/O를 기다리고 있는 PCB 5번도 보인다.</p><h3 id="Queueing-Diagram"><a href="#Queueing-Diagram" class="headerlink" title="Queueing Diagram"></a>Queueing Diagram</h3><p>프로세스 스케쥴링을 표현하는 대표적인 방법이 바로 Queueing Diagram이다. cpu와 ready queue, 그리고 각 device에서의 I/O를 기다리는 wait queue들간의 관계를 표시해 두었다. 아래 그림을 해석해 보자.</p><p><img src="https://user-images.githubusercontent.com/25416425/145781067-b8ccad2d-06c4-4810-9b3b-77831f16f30e.png" alt="image"></p><p>먼저, ready queue에 있던 프로세스는 cpu를 획득하여 running 상태가 된다. 이때, 별 일 없이 프로세스가 마무리된 후 cpu를 빠져나가 terminate 될 수도 있다. 이제, 그렇지 않은 아래 경우를 보자. </p><ul><li>I/O request가 들어오면, 해당 프로세스는 I/O queue에서 waiting 상태가 된다. 이후 I/O가 마무리되면 다시 ready queue로 들어가서 대기한다.</li><li>time slice expired는 특정 단위의 시간을 정하고, 해당 시간이 지나면 자동으로 expired 처리를 하여 running 중의 프로세스를 중지하는 것을 의미한다. 해당 성격의 interrupt는 어떤 이벤트가 발생할 때 까지 기다리는 것은 아니기 때문에, wait queue가 아니라 곧바로 ready queue로 들어가는 것을 확인할 수 있다.</li><li>fork a child는 running 중인 부모 프로세스가 자식 프로세스를 생성했을 때를 의미한다. 생성된 자식 프로세스는 new 상태를 거쳐 ready queue로 들어간다.</li><li>어떤 interrupt가 발생할 때까지 wait queue에서 기다릴 수도 있다. 해당 interrupt가 발생하면, 이제 프로세스는 wait 상태에서 ready 상태로 바뀌게 된다.</li></ul><h3 id="Context-Switch"><a href="#Context-Switch" class="headerlink" title="Context Switch"></a>Context Switch</h3><p>프로세스의 상태가 running에서 ready로, 그리고 ready에서 다시 running으로 바뀌는 경우를 앞에서 많이 보았다. 우리의 cpu는 단 한순간도 멈춰있으면 안되기에, 해당 프로세스가 ready나 wait상태로 바뀌었다면 이는 다른 프로세스가 cpu를 점유하러 들어갔다는 것을 의미한다. cpu를 두고 프로세스가 마치 교환된 것 처럼 보인다.</p><p>문맥 교환 (Context Switch)은 cpu 코어에 다음 프로세스를 배치 및 복원하고, 현재 돌고 있었던 프로세스의 정보를 저장하는 일련의 과정을 의미한다. 문맥 교환을 수행하는 주체는 당연히 운영체제! 그렇다면 문맥은 무엇일까?</p><p>프로세스에서의 문맥 (Context)이란, <strong>PCB 내에 저장된 정보</strong>들을 의미한다. Interrupt가 발생했을 때, 시스템은 running하고 있는 프로세스의 현재 문맥을 저장해 두어야 다음에 다시 running 상태가 되었을 때 문맥을 복원할 수 있을 것이다. 이 때, 제일 중요한 부분이 바로 프로그램이 어디까지 실행되었는지 알고 있는 <strong>program counter (pc)</strong>이다. </p><p><img src="https://user-images.githubusercontent.com/25416425/145954652-5f4afcfc-92e5-45ec-bd30-7b5c95eaf37c.png" alt="image"></p><p>위 그림을 차례대로 해석해 보자.</p><ol><li>처음에는 0번 process가 cpu를 점유하여 executing 하고 있는 상태였다.</li><li>그런데 I/O interrupt인지 time expired인지 그런 원인에 의해 더이상 cpu를 점유할 수 없는 상태가 되었다.</li><li>그 즉시 0번 process의 정보를 담고 있는 0번 PCB에 상태가 저장 (save) 된다.</li><li>그리고 cpu에는 1번 process의 정보를 담고 있는 1번 PCB가 복원 (reload) 된다.</li><li>1번 process가 cpu를 점유했고, running 상태가 된다.</li><li>다시 2번과 같은 interrupt가 발생했고, 마찬가지로 1번 PCB에 정보가 저장된 후 0번 PCB가 다시 복원된다.</li><li>0번 process가 cpu를 점유하고 running 상태가 된다.</li></ol><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>ready 및 wait queue들은 PCB의 linked list로 구현될 수 있다.</li><li>프로세스에서의 context는 PCB 내에 저장된 정보를 의미한다.</li><li>context switch는 OS에 의해 진행되며, 각 프로세스의 pc를 저장해 두었다가 다시 실행될 때 복원하는 작업이다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;프로세스-스케쥴링&quot;&gt;&lt;a href=&quot;#프로세스-스케쥴링&quot; class=&quot;headerlink&quot; title=&quot;프로세스 스케쥴링&quot;&gt;&lt;/a&gt;프로세스 스케쥴링&lt;/h2&gt;&lt;p&gt;우리는 일반적으로 많은 프로그램을 동시에 사용하고 있다.&lt;br&gt;실행 중인 프로그램을 프로세스라고 하기에, 많은 프로세스가 동시에 동작하고 있다고 생각할 수 있겠다.&lt;br&gt;하지만, 가장 기본적인 cpu core 구성이라고 가정하였을 때 하나의 프로세스가 cpu를 점유하고 있으면 다른 프로세스는 이를 기다려야 한다.&lt;br&gt;그렇다면, 누가 먼저 실행되고 누가 나중에 실행되는가? 나중에 실행되는 프로세스는 이전 프로세스가 종료될 때 까지 계속 기다려야 하는가? 이런 의문점들이 생긴다.&lt;br&gt;또한, 우리는 cpu를 최대한 효율적으로 사용함과 동시에 위에 언급한 대로 하나의 프로그램이 아니라 여러 개의 프로그램과 동시에 상호작용을 하고 싶다. 유튜브 보면서 카카오톡도 하고, 게임도 해야할 것 아닌가? 이러한 상황에 직면하면, 우리는 프로세스를 스케쥴링 (Process Scheduling) 하는 것이 얼마나 중요한 것인지 깨닫게 된다.&lt;br&gt;이번 포스트에서는 아직 multiprogramming까지는 다루지 않고, 프로세스들 간의 교환이 어떻게 이루어지는지를 먼저 살펴본다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
      <category term="process" scheme="https://jeongwookie.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>백준 1018번 - 체스판 다시 칠하기</title>
    <link href="https://jeongwookie.github.io/2021/12/12/programming/codingtest/bruteforce/1-baekjoon-1018/"/>
    <id>https://jeongwookie.github.io/2021/12/12/programming/codingtest/bruteforce/1-baekjoon-1018/</id>
    <published>2021-12-12T08:25:37.000Z</published>
    <updated>2021-12-12T08:37:25.104Z</updated>
    
    <content type="html"><![CDATA[<p>코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.</p><a id="more"></a><h2 id="백준-1018-체스판-다시-칠하기"><a href="#백준-1018-체스판-다시-칠하기" class="headerlink" title="백준 1018: 체스판 다시 칠하기"></a>백준 1018: 체스판 다시 칠하기</h2><p>문제 출처 : <a href="https://www.acmicpc.net/problem/1018" rel="external nofollow noopener noreferrer" target="_blank">https://www.acmicpc.net/problem/1018</a><br><img src="https://user-images.githubusercontent.com/25416425/145705691-7056894e-4d24-4251-99e2-a9ab7fb8eea5.png" alt="image"></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>일단 문제를 읽고 체스판 자체를 코드로 구현해야 한다.<br>그리고 체스판을 구성할 수 있는 모든 경우의 수를 다 세어가면서 (브루트 포스) 최소 값을 구하면 되는 문제이다.<br>체스판을 칠할 때, 먼저 8 by 8 체스판을 구성할 수 있는 모든 경우의 수를 파악하고<br>이후 해당 체스판을 픽한 후 그 체스판을 칠할 수 있는 모든 경우의 수를 계산한다.<br>브루트 포스 문제는 모든 경우를 빠지지 않고 검사하였는지 꼼꼼히 따져보는 것이 핵심!!</p><h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[플이 논리]</span><br><span class="line"><span class="number">1.</span> <span class="number">8</span> by <span class="number">8</span> 체스판 몇개를 구성할 수 있는지 <span class="keyword">for</span>문을 통해 파악한다.</span><br><span class="line"><span class="number">2.</span> 이 때, 시작점으로 할 수 있는 정사각형의 경우의 수를 세면 편하다.</span><br><span class="line"><span class="number">3.</span> 다 세었다면, 딱 하나의 경우로 fix한 후 그 board를 체스판으로 만들려면 최소 몇개를 칠해야 하는지 계산하는 함수를 구성한다.</span><br><span class="line"><span class="number">4.</span> 체스판으로 만들 수 있는 모든 경우를 세려면, 시작점이 B인 체스판 구성 또는 시작점이 W인 체스판 구성 이렇게 두가지만 세어주면 모든 경우가 커버된다.</span><br><span class="line"><span class="number">5.</span> 해당 경우에 최소 몇번의 정사각형을 칠해야 하는지 각각 세어서 리턴해주면 종료!</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_chess_board</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    starting point : (i,j)</span></span><br><span class="line"><span class="string">    start_white : W로 시작하는 체스판을 구성하는 경우, 칠해야 하는 최소 정사각형 개수</span></span><br><span class="line"><span class="string">    start_black : B로 시작하는 체스판을 구성하는 경우, 칠해야 하는 최소 정사각형 개수</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 초기화</span></span><br><span class="line">    start_white, start_black = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># for loop 으로 보드 전체 탐색</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(i, i+<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(j, j+<span class="number">8</span>):</span><br><span class="line">            <span class="keyword">if</span> (x + y) % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 징검다리 탐색을 위한 테크닉</span></span><br><span class="line">                <span class="keyword">if</span> board[x][y] == <span class="string">"W"</span>: <span class="comment"># 시작점이 W이면,</span></span><br><span class="line">                    start_black += <span class="number">1</span> <span class="comment"># 시작을 B로 하는 체스판 만들려면 칠해야함</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 시작점이 B이면,</span></span><br><span class="line">                    start_white += <span class="number">1</span> <span class="comment"># 시작을 W로 하는 체스판 만들려면 칠해야함</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> board[x][y] == <span class="string">"B"</span>: <span class="comment"># 두번째 칸이 B이면,</span></span><br><span class="line">                    start_black += <span class="number">1</span> <span class="comment"># 시작을 B로 하는 체스판 만들려면 W로 칠해야함</span></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 두번째 칸이 W이면,</span></span><br><span class="line">                    start_white += <span class="number">1</span> <span class="comment"># 시작을 W로 하는 체스판 만들려면 B로 칠해야함</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> start_white, start_black</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys; readline = sys.stdin.readline</span><br><span class="line">    N, M = map(int, readline().split())</span><br><span class="line">    board = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        board.append([i <span class="keyword">for</span> i <span class="keyword">in</span> readline().strip()])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 시작점 경우의 수 계산하기</span></span><br><span class="line">    answer = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(M<span class="number">-8</span>+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 시작점이 (i,j) 인 체스 보드</span></span><br><span class="line">            start_white, start_black = make_chess_board(i,j)</span><br><span class="line">            answer.append(min(start_white, start_black))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 최종적으로 min값 선정</span></span><br><span class="line">    print(min(answer))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅱ. Programming" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/"/>
    
      <category term="코딩 테스트 문제 풀이" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/"/>
    
      <category term="브루트 포스" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Codingtest" scheme="https://jeongwookie.github.io/tags/Codingtest/"/>
    
      <category term="Baekjoon" scheme="https://jeongwookie.github.io/tags/Baekjoon/"/>
    
      <category term="bruteforce" scheme="https://jeongwookie.github.io/tags/bruteforce/"/>
    
      <category term="implementation" scheme="https://jeongwookie.github.io/tags/implementation/"/>
    
  </entry>
  
  <entry>
    <title>백준 2178번 - 미로 탐색</title>
    <link href="https://jeongwookie.github.io/2021/12/08/programming/codingtest/dfs&amp;bfs/3-baekjoon-2178/"/>
    <id>https://jeongwookie.github.io/2021/12/08/programming/codingtest/dfs&amp;bfs/3-baekjoon-2178/</id>
    <published>2021-12-08T09:01:24.000Z</published>
    <updated>2021-12-08T08:57:21.685Z</updated>
    
    <content type="html"><![CDATA[<p>코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.</p><a id="more"></a><h2 id="백준-2178-미로-탐색"><a href="#백준-2178-미로-탐색" class="headerlink" title="백준 2178: 미로 탐색"></a>백준 2178: 미로 탐색</h2><p>문제 출처 : <a href="https://www.acmicpc.net/problem/2178" rel="external nofollow noopener noreferrer" target="_blank">https://www.acmicpc.net/problem/2178</a></p><p><img src="https://user-images.githubusercontent.com/25416425/145166687-2a0da963-a253-49b5-8b7c-de7d4b302ddb.png" alt="image"></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>출발 지점과 도착 지점이 주어진 <strong>최단 거리 구하기</strong> 문제 이다.<br>한 지점을 기준으로 BFS를 차근차근 수행해가며 값을 누적시키면 문제를 해결할 수 있다.<br>최단 거리 문제가 나오면 일단 BFS를 떠올려 보자!</p><h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[풀이 논리]</span><br><span class="line"><span class="number">1.</span> 시작점이 (<span class="number">1</span>,<span class="number">1</span>)이고 도착점이 (N,M)이므로, 한칸씩 당겨서 시작점을 (<span class="number">0</span>,<span class="number">0</span>) 도착점을 (N<span class="number">-1</span>,M<span class="number">-1</span>)로 설정한다.</span><br><span class="line"><span class="number">2.</span> visited라는 리스트를 만들고 주어진 graph와 dim을 맞춰서 <span class="number">0</span>을 넣어놓는다.</span><br><span class="line"><span class="number">3.</span> 시작점에서 시작해서 bfs를 수행하고, 해당 지점이 도착점과 같아질 때 함수를 종료한다.</span><br><span class="line"><span class="number">4.</span> 지점을 방문할때마다 visited의 값을 누적시킨다.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 상하좌우</span></span><br><span class="line">    dx = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    dy = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    queue = deque([start]) <span class="comment"># (0,0)을 q에 넣고</span></span><br><span class="line">    visited[start[<span class="number">0</span>]][start[<span class="number">1</span>]] = <span class="number">1</span> <span class="comment"># 방문 처리</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        x, y = queue.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x == end[<span class="number">0</span>] <span class="keyword">and</span> y == end[<span class="number">1</span>]: <span class="comment"># 종료 조건</span></span><br><span class="line">            <span class="keyword">return</span> visited[x][y]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>): <span class="comment"># 상하좌우로 인접 탐색</span></span><br><span class="line">            next_x, next_y = x + dx[i], y + dy[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> valid(next_x, next_y): <span class="comment"># 좌표가 유효한 경우,</span></span><br><span class="line">                queue.append([next_x, next_y]) <span class="comment"># 해당 좌표를 큐에 넣고</span></span><br><span class="line">                visited[next_x][next_y] = visited[x][y] + <span class="number">1</span> <span class="comment"># 방문처리하여 값 누적</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; M: <span class="comment"># 범위에서 벗어나지 않고,</span></span><br><span class="line">        <span class="keyword">if</span> graph[x][y] == <span class="number">1</span> <span class="keyword">and</span> visited[x][y] == <span class="number">0</span>: <span class="comment"># 길이 있고, 방문한 적이 없다면</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys; readline = sys.stdin.readline</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    N, M = map(int, readline().split())</span><br><span class="line">    graph = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        _list = [int(i) <span class="keyword">for</span> i <span class="keyword">in</span> readline().strip()]</span><br><span class="line">        graph.append(_list)</span><br><span class="line"></span><br><span class="line">    start = [<span class="number">0</span>, <span class="number">0</span>] <span class="comment"># (1,1)이 처음이므로 1칸씩 뒤로 당김</span></span><br><span class="line">    end = [N<span class="number">-1</span>, M<span class="number">-1</span>]</span><br><span class="line">    visited = [[<span class="number">0</span>] * M <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)] <span class="comment"># 0으로 초기화</span></span><br><span class="line">    print(bfs())</span><br></pre></td></tr></table></figure><blockquote><p><strong>풀이 포인트</strong><br>최단 거리 구하기 문제는 BFS 떠올리기<br>값 누적시킬 visited 리스트를 새로 만들기<br>내가 실수했던 부분 : visited 리스트 만들 때 리스트 구조를 이상하게 만들었었음 ㅠ<br>얌전하게 [[0] * M for _ in range(N)] 이런식으로 합시다..<br>아니면 걍 [[0 for _ in range(M)] for _ in range(N)] 이렇게 적던가</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅱ. Programming" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/"/>
    
      <category term="코딩 테스트 문제 풀이" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/"/>
    
      <category term="DFS와 BFS" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/DFS%EC%99%80-BFS/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Codingtest" scheme="https://jeongwookie.github.io/tags/Codingtest/"/>
    
      <category term="Baekjoon" scheme="https://jeongwookie.github.io/tags/Baekjoon/"/>
    
      <category term="DFS&amp;BFS" scheme="https://jeongwookie.github.io/tags/DFS-BFS/"/>
    
  </entry>
  
  <entry>
    <title>OS공부 - 프로세스 정의</title>
    <link href="https://jeongwookie.github.io/2021/12/06/computerscience/operatingsystem/3-what-is-process/"/>
    <id>https://jeongwookie.github.io/2021/12/06/computerscience/operatingsystem/3-what-is-process/</id>
    <published>2021-12-06T09:03:20.000Z</published>
    <updated>2021-12-14T08:48:30.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="프로세스의-정의"><a href="#프로세스의-정의" class="headerlink" title="프로세스의 정의"></a>프로세스의 정의</h2><p><strong>프로세스 (process)</strong> 란, 실행 중인 프로그램을 뜻한다.</p><p>HDD, SSD와 같은 스토리지에 우리가 작성한 코드 파일이 있을 것이다. 이런 명령어들의 집합으로 구성된 프로그램을 실행시키게 되면 해당 정보들이 메모리에 로드 된다. 해당 프로그램은 이제 cpu가 fetch해서 연산할 수 있는 상태가 되는데, 해당 상태에 있는 프로그램을 프로세스 라고 할 수 있겠다. 이제 이 프로세스는 cpu를 점유하거나, 파일을 열거나, I/O 장치들과 신호를 주고 받게 될 것이다. 운영체제가 해야 하는 가장 기본적인 활동은 <u>바로 프로세스를 관리하는 것이다</u>.</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/25416425/144813252-f2160a8b-923b-4978-ac3f-8b20efcf79bf.png" alt="image"></p><p>프로세스는 위 그림과 같은 주소 공간을 필요로 하게 된다. text 영역에는 우리가 작성한 프로그램 코드가 들어 있고, data에는 전역 변수가, heap 영역에는 동적으로 할당된 메모리가 들어 있다. C에서는 <code>malloc</code>, Java에서는 <code>new</code>와 같은 코드가 메모리 동적 할당을 수행한다. stack 영역은 임시 데이터 저장 공간이라고 할 수 있는데 여기는 지역 번수, 함수의 매개 변수, 리턴값의 주소 등이 들어 있다. stack 영역은 위에서부터 아래로 커지고, heap 영역은 아래에서 위로 커지는 방식이다. 이렇게 쭉 쌓아오다가 만약 부족해지면 다른 메모리 영역을 참조하기도 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x; <span class="comment">// uninitialized data section</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">15</span>; <span class="comment">// initialized data section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> <span class="comment">// stack section</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *values; <span class="comment">// stack section </span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// stack section</span></span><br><span class="line"></span><br><span class="line">    values = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">5</span>) <span class="comment">// heap section</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) <span class="comment">// text section에서 수행</span></span><br><span class="line">        values[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 프로그램이 종료되고, 다시 제어권을 os에게 넘겨줌</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 소스 코드가 우리가 일반적으로 작성하는 형태이고, 이를 컴파일 하여 <code>a.out</code> 이라는 프로그램을 만들 수 있다. 해당 프로그램이 메모리에 로드되면서 각각의 section을 차지하게 되는 이런 일련의 동작을 프로세스 라고 할 수 있겠다. (즉, 실행중인 프로그램!)</p><blockquote><p><strong>프로그램을 실행시키는 방법</strong><br>Load : Disk에 있는 프로그램을 DRAM과 같은 메모리에 프로세스로 적재한다.<br>Dynamic Allocation : 메모리에 적재된 프로그램의 데이터를 위 그림처럼 배치한다.<br>Initialization : 미리 처리되어야 할 file descriptor 및 I/O 를 처리한다.<br>Jump to Entry point : C언어에서는 main() 함수와 같이 시작지점으로 점프한다.</p></blockquote><h2 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h2><p>프로세스는 총 다섯 가지 상태를 가질 수 있다.</p><ul><li>new :  프로세스가 생성 되었을 때</li><li>ready : 프로세스가 cpu를 할당 받기를 기다리고 있을 때 (준비 완료!)</li><li>running : 명령어들이 실행되고 있을 때</li><li>waiting : 프로세스가 어떤 이벤트가 발생하기를 기다리고 있을 때</li><li>terminated : 프로세스가 종료 되었을 때</li></ul><p><img src="https://user-images.githubusercontent.com/25416425/144817003-230dce48-06b1-488e-898b-d4e028870858.png" alt="image"></p><p>위 그림을 순서대로 해석 해 보자.</p><ol><li><code>fork()</code>라는 시스템 콜을 통해서 사용자는 프로세스 생성을 os에게 요청할 수 있다. (new 상태)</li><li>프로그램을 프로세스로 만드는 여러 작업들을 거친 후, cpu에게 점유할 준비가 다 되었다고 알려주기 위해 ready queue에 들어간다. (ready 상태)</li><li>cpu 스케쥴러는 이를 확인하고, 정책에 따라 ready 상태의 프로세스를 cpu에 dispatch한다. (running 상태) </li><li>프로세스는 cpu 스케쥴러의 판단에 따라서 다시 ready 상태로 옮겨지기도 한다. (interrupt 발생) </li><li>만약 I/O 요청 또는 다른 event가 발생하여 잠시 프로세스의 실행을 멈춰야 할 때도 있다. (waiting 상태)</li><li>I/O 요청이 종료되면, 해당 프로세스는 다시 cpu를 점유할 수 있는 상태가 되므로 ready queue에 들어가서 대기한다.</li><li>마지막으로 <code>exit()</code>과 같은 명시적인 종료 시스템 콜이 들어오면, 프로세스는 종료된다. (terminated 상태)</li></ol><h2 id="프로세스-컨트롤-블록"><a href="#프로세스-컨트롤-블록" class="headerlink" title="프로세스 컨트롤 블록"></a>프로세스 컨트롤 블록</h2><p><strong>프로세스 컨트롤 블록 (Process Control Block, PCB)</strong>은 운영체제가 가지고 있는 프로세스에 대한 정보의 총집합이다.<br>다시 말하면, 운영체제가 프로세스 스케쥴링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스를 의미한다.</p><p>각 프로세스가 생성될 때 마다 고유의 PCB가 생성되고, 프로세스가 완료되면 제거된다. 이런 정보 구조체가 실제로 어떻게 쓰일까? 프로세스는 기본적으로 cpu를 점유하여 작업을 처리한다. 그런데, 우리가 앞서 살펴본 process state에 따르면 프로세스가 running 상태에 있더라도 특정 이벤트 혹은 interrupt에 의해 ready나 wait 상태로 바뀐다. 이때 PCB를 활용하여, 방금 전까지 작업한 내용들을 전부 저장해 둔다. 이후 다시 해당 프로세스가 cpu를 점유하게 되면 (running 상태) PCB로부터 해당 정보들을 불러와서 작업을 이어서 진행할 수 있게 된다. </p><p><img src="https://user-images.githubusercontent.com/25416425/145335493-9b5e84a0-0892-4c0f-8a0a-3434f17bd1df.png" alt="image"></p><p>PCB는 위 그림과 같은 구조로 이루어져 있다. 중요한 몇 가지만 짚고 넘어가자.</p><ul><li>프로세스 식별자 (process ID)</li><li>프로세스 상태 (process state) : ready? wait? 이런 상태들을 저장해두어야 한다.</li><li><strong>프로그램 카운터 (program counter, pc)</strong> : 해당 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.</li><li>cpu 및 일반 레지스터</li><li>cpu 스케쥴링 정보 : 최종 실행 시각, 우선 순위, 점유 시간 등등</li><li>메모리 관리 정보 : 해당 프로세스의 주소 공간</li><li>프로세스 계정 정보</li><li>입출력 상태 정보 : 프로세스에 할당돤 입출력장치 목록, 열린 파일 목록 등</li></ul><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>프로세스란, 실행 중인 프로그램을 뜻함</li><li>프로세스가 필요한 메모리 주소 공간은 text, data, heap, stack이 있음</li><li>ready 상태의 프로세스는 cpu 스케쥴러에 의해 running 상태로 바뀜</li><li>running 상태의 프로세스는 I/O interrupt에 의해 wait 상태로 바뀔 수 있음</li><li>running 상태의 프로세스는 cpu 스케쥴러에 의해 interrupt 되어 다시 ready 상태로 바뀔 수 있음</li><li>PCB는 프로세스의 정보를 담고 있는 데이터베이스임. 프로세스가 스케쥴링되어 바뀔 때 유용하게 사용됨</li><li>특히, 프로그램 카운터 (pc)는 해당 프로세스가 다음에 실행할 명령어의 주소를 저장하고 있음</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;프로세스의-정의&quot;&gt;&lt;a href=&quot;#프로세스의-정의&quot; class=&quot;headerlink&quot; title=&quot;프로세스의 정의&quot;&gt;&lt;/a&gt;프로세스의 정의&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;프로세스 (process)&lt;/strong&gt; 란, 실행 중인 프로그램을 뜻한다.&lt;/p&gt;
&lt;p&gt;HDD, SSD와 같은 스토리지에 우리가 작성한 코드 파일이 있을 것이다. 이런 명령어들의 집합으로 구성된 프로그램을 실행시키게 되면 해당 정보들이 메모리에 로드 된다. 해당 프로그램은 이제 cpu가 fetch해서 연산할 수 있는 상태가 되는데, 해당 상태에 있는 프로그램을 프로세스 라고 할 수 있겠다. 이제 이 프로세스는 cpu를 점유하거나, 파일을 열거나, I/O 장치들과 신호를 주고 받게 될 것이다. 운영체제가 해야 하는 가장 기본적인 활동은 &lt;u&gt;바로 프로세스를 관리하는 것이다&lt;/u&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
      <category term="process" scheme="https://jeongwookie.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>OS공부 - 운영체제의 개념과 구조</title>
    <link href="https://jeongwookie.github.io/2021/12/04/computerscience/operatingsystem/2-os-structures-intro/"/>
    <id>https://jeongwookie.github.io/2021/12/04/computerscience/operatingsystem/2-os-structures-intro/</id>
    <published>2021-12-04T13:11:20.000Z</published>
    <updated>2021-12-06T09:33:31.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="운영-체제의-정의"><a href="#운영-체제의-정의" class="headerlink" title="운영 체제의 정의"></a>운영 체제의 정의</h2><p>운영 체제 (Operating System)에 대해서 다시 정의를 짚어보고 넘어가자.</p><ul><li>OS는 컴퓨터의 하드웨어를 manage하는 소프트웨어이다.</li><li>OS는 컴퓨터 유저와 컴퓨터 하드웨어간의 매개 역할을 수행한다.</li></ul><p>이해를 돕기 위해 우리는 컴퓨터 시스템이 어떻게 구성되어 있는지 알아야 한다. 크게 4가지 component로 구성되어 있는데, 하드웨어, 운영체제, 응용 프로그램, 그리고 유저 이다. 유저가 행하는 다양한 프로그래밍이 접근하는 프로그램은 컴파일러, 어셈블러, 텍스트 에디터, 데이터베이스 시스템 등 다양하다. 이러한 시스템 프로그래밍 혹은 어플리케이션 프로그래밍을 할때 운영체제와 통신하면, 운영체제가 대신 하드웨어에 접근하는 방식으로 구성되어 있다. 아래의 그림을 참고하자.</p><a id="more"></a><p><img src="https://user-images.githubusercontent.com/25416425/144545482-4253256d-cab3-4325-a2db-f55ddf99181e.png" alt="image"></p><p>공룡책의 저자는 운영체제를 정의함에 있어서 어떤 universally하게 받아들여지는 정의는 없다고 한다. 대신, 더 common한 정의를 가져왔는데, 이는 아래와 같다.</p><blockquote><p>The one program running at all times on the computer. Usually called the kernel.</p></blockquote><p>앞으로 우리는 운영체제에서 특히 <strong>kernel</strong>이라고 불리는 부분에서 어떠한 동작이 발생하는지에 대해서 주로 관심있게 공부할 것이다.</p><h2 id="컴퓨터-시스템-구조"><a href="#컴퓨터-시스템-구조" class="headerlink" title="컴퓨터 시스템 구조"></a>컴퓨터 시스템 구조</h2><p>현대 컴퓨터 시스템은 하나 이상의 CPU를 가지고 있으며, 다양한 장치 컨트롤러들이 common bus를 통해 연결되어 있다. 아래의 그림을 참고하자. disk에는 HDD와 SSD가 사용되며, 마우스 키보드와 같은 Input 장치들과 프린터 모니터와 같은 Output 장치들 또한 메모리와 연결되어 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/144707234-af49bba4-5ba2-47e8-a239-393f2e8e02c1.png" alt="image"></p><h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>컴퓨터의 전원을 켜는 것을 우리는 부팅 한다고 표현한다. 이 때 컴퓨터를 동작시키는 프로그램이 바로 bootstrap 이라는 프로그램인데, 해당 프로그램이 해야할 역할은 당연하게도 OS를 불러와서 메모리에 로드하는 것이다. 그렇다면 bootstrap program은 어디에 저장되어 있을까? 휘발성 메모리에 부팅 시스템과 관련한 명령어들을 넣어 놓는다면, 부팅시마다 초기화 되기 때문에 큰일이 날 것이다. 그래서 이 중요한 프로그램은 <u>EEPROM과 같은 불휘발성 메모리에 저장된다.</u> 블휘발성 메모리는 전원이 끊어져도 기록된 데이터들이 소멸되지 않는 특성이 있다.</p><h3 id="Interrupts"><a href="#Interrupts" class="headerlink" title="Interrupts"></a>Interrupts</h3><p>CPU와 I/O devices 사이에 통신하는 방법 중의 하나가 바로 interrupts이다. 예를 들어서 우리가 키보드로 A라는 문자를 눌렀다고 하자. 이를 CPU에게 알려 주기 위해 transfer을 진행하고, CPU는 하던 일 (user process) 을 멈추고 이를 받아들인다. 이러한 매커니즘이 마치 CPU의 현재 동작을 방해하는 것처럼 이루어지므로 Interrupt라는 이름에 참 알맞다. 아래의 그림은 Interrupt가 발생하는 타임라인을 개략적으로 표현한 것이다. </p><p><img src="https://user-images.githubusercontent.com/25416425/144707547-e8235d42-3988-4240-8818-d65a6afd3164.png" alt="image"></p><p>이처럼 Interrupts는 하드웨어에 의해 언제든 유발될 수 있으며 동작 방식은 간단하다. CPU에 특정 시그널을 보내는 것이다.</p><h3 id="Storage-Device-Hierarchy"><a href="#Storage-Device-Hierarchy" class="headerlink" title="Storage Device Hierarchy"></a>Storage Device Hierarchy</h3><p>우리의 컴퓨터는 여러 종류의 저장 장치로 구성되어 있다. 프로그램의 목적에 따라 저장 장치를 활용하게 되는데, 예를 들어서 이전에 살펴본 Bootstrap은 RAM과 같은 휘발성 메모리에 저장되면 안될 것이다. 저장 장치들은 저장 용량과 엑세스 타임에 따라서 여러 개의 계층 구조를 가지고 있다. 아래의 그림을 참고하자.</p><p><img src="https://user-images.githubusercontent.com/25416425/144708062-e2074a9d-4944-4692-9298-19b5f1cb52d1.png" alt="image"></p><p>메인 메모리는 우리가 흔히 이야기하는 RAM이다. 여기까지가 휘발성 메모리. 그 바로 아래부터 비휘발성 메모리로, ssd와 hdd같은 저장 디스크들, 그리고 더 아래로 내려가면 광학 디스크와 마그네틱 테잎과 같은 저장 장치들이 있다. 상위 계층으로 갈수록 작은 저장 용량을 가지지만 속도가 매우 빨라진다. 가격도 비싸다..</p><h4 id="레지스터-Register"><a href="#레지스터-Register" class="headerlink" title="레지스터 (Register)"></a>레지스터 (Register)</h4><p>CPU 내에 위치한, 극히 소량의 데이터나 처리중인 중간 결과를 일시적으로 기억해 두는 고속의 전용 영역이며, 현재 수행하는 값을 기억한다. 그림 상 레지스터 위에 CPU가 있다고 이해하면 된다. </p><h4 id="캐시-Cache"><a href="#캐시-Cache" class="headerlink" title="캐시 (Cache)"></a>캐시 (Cache)</h4><p>CPU와 메모리 사이에 자주 쓰는 것을 가까운 곳에 저장하기 위해 사용하는 메모리.<br>메인 메모리에 있는 데이터를 캐시 메모리에 불러와 두고, CPU가 필요한 데이터를 캐시에서 먼저 찾도록 하면, 시스템 성능을 크게 향상시킬 수 있다.</p><blockquote><p><strong>레지스터와 캐시의 차이는?</strong><br>: <strong>캐시</strong>는 <u>CPU와 별도로 있는 저장 공간이며,</u> 메인 메모리와 CPU 간의 속도 차이를 극복하기 위한 것이다. 반면 <strong>레지스터</strong>는 <u>CPU 안에서 연산을 처리하기 위해</u>  데이터를 저장하는 공간이다.</p></blockquote><h3 id="I-O-Structures"><a href="#I-O-Structures" class="headerlink" title="I/O Structures"></a>I/O Structures</h3><p>아래 그림은 I/O 장치가 정보를 전달할때, CPU와 메모리에서 어떻게 동작하는지를 개략적으로 보여준다.</p><p><img src="https://user-images.githubusercontent.com/25416425/144708678-695e94d7-1aed-4049-b37a-5b4ba9d937a2.png" alt="image"></p><p>CPU에서 어떤 프로그램이 실행되면, 이는 캐시 메모리를 거쳐 메모리 영역의 명령어들과 데이터를 읽어온다. CPU가 I/O request를 device에 전달하면, device는 앞서 설명하였던 interrupt를 발생시키고, 이는 실행하고 있는 프로그램을 wait하게 하기도 한다. CPU의 연산이 불필요할 경우, device에서 직접 메모리로 정보를 주고받는 일종의 interrupt도 발생할 수 있는데 이를 <strong>Direct Memory Access (DMA)</strong> 라고 한다. 유튜브 동영상을 보는 것에 CPU가 열심히 계산할 필요는 없지 않을까? Network에서 데이터를 읽어서 그대로 모니터로 영상을 쏴주고, CPU는 가만히 있다가 사용자가 동영상을 멈춘다던지 뭔가 액션을 취할때만 연산을 해주면 더 효율적일 것이다.</p><h2 id="컴퓨터-시스템-아키텍쳐"><a href="#컴퓨터-시스템-아키텍쳐" class="headerlink" title="컴퓨터 시스템 아키텍쳐"></a>컴퓨터 시스템 아키텍쳐</h2><p>프로세서는 1개인데 코어가 여러 개 라는 것이 무엇을 의미할까? 쿼드코어를 넘어서서 8-코어 등의 용어를 우리는 많이 접해보았을 것이다. 아래의 개념을 먼저 짚고 넘어가자.</p><ul><li>CPU (Central Processing Unit): 명령어를 실행하는 하드웨어 장치. 중앙 처리 장치.</li><li>Processor : 기본적인 명령어들을 처리하는 논리회로. 일반적인 PC환경에서 프로세서와 CPU는 같은 개념으로 보아도 무방하다고 한다.</li><li>Core : 각종 연산을 하는 CPU의 핵심 요소. 하나의 프로세서 안에 4개의 코어가 있다는 것은 4명이 분담해서 일을 처리한다고 이해하면 된다. Core의 종류는 ARM, MIPS, x86 등의 ISA (Instruction Set Architecture) 로 구별된다.</li></ul><p><img src="https://user-images.githubusercontent.com/25416425/144709730-5fdb828d-9560-4247-8bd0-6c144ef5ac38.png" alt="image"></p><p>동일한 프로세서 칩에 여러 개의 코어가 있으면 멀티코어, 프로세서가 여려개 있으면 그게 바로 멀티프로세서 이다.</p><blockquote><p><strong>잠깐, ISA가 뭐지?</strong><br>: CPU가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어들의 set을 의미한다. 사용자가 실행한 응용 어플리케이션은 하단에 존재하는 알고리즘, 프로그래밍 언어, 어셈블리어, 기계어 등 소프트웨어 파트를 거쳐서 하드웨어 파트로 넘어가게 되는데 이때 소프트웨어와 하드웨어의 중재 역할을 하는 부분이 바로 ISA이다. 다시 말하면 최하위 레벨의 프로그래밍 인터페이스로, 프로세서 (cpu)가 실행할 수 있는 모든 명령어들을 포함한다.</p></blockquote><h2 id="운영-체제의-실제-운영-방식"><a href="#운영-체제의-실제-운영-방식" class="headerlink" title="운영 체제의 실제 운영 방식"></a>운영 체제의 실제 운영 방식</h2><p>운영 체제는 두 가지 모드로 나누어 운영을 하게 되는데, 이를 <strong>user mode</strong>와 <strong>kernel mode</strong> 라고 한다.<br>user mode에서는 우리가 일반적으로 실행하는 프로그램들이 동작한다. 반면 kernel mode에서는 OS 코드를 실행한다. 이렇게 모드를 나누는 이유는, 유저가 혹시 잘못된 프로그램을 동작 시켰을 때 컴퓨터 전체의 동작이 망가지는 것을 대비하기 위함이다.</p><p><img src="https://user-images.githubusercontent.com/25416425/144710603-4510ced8-d344-485b-878b-fcbc6be50dca.png" alt="image"></p><p>위의 그림을 보면 kernel mode가 언제 등장하는지 이해할 수 있다. 유저 프로세스는 user mode에서 실행되고 있다. 이때 유저 프로세스가 system call이라는 방식으로 OS를 부르면, 이때 trap이 발생하면서 kernel mode로 진입된다. 그리고 system call이 수행된 후 다시 user mode로 리턴된다. 이러한 seperate mode 동작 방식으로 OS는 의도치 않은 동작을 하는 프로그램이 자칫 다른 프로그램이나 디바이스에 영향을 주는 것을 원천적으로 차단할 수 있는 것이다.</p><p>마지막으로, 운영 체제가 어떤 서비스를 제공하는지 그림으로 살펴본다. 뭐 그냥 중요한걸 다 한다고 볼 수 있다.<br>OS 없으면 못살어<del>~</del>~</p><p><img src="https://user-images.githubusercontent.com/25416425/144710798-4d768917-895f-4371-9a94-335cdede9a86.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;운영-체제의-정의&quot;&gt;&lt;a href=&quot;#운영-체제의-정의&quot; class=&quot;headerlink&quot; title=&quot;운영 체제의 정의&quot;&gt;&lt;/a&gt;운영 체제의 정의&lt;/h2&gt;&lt;p&gt;운영 체제 (Operating System)에 대해서 다시 정의를 짚어보고 넘어가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OS는 컴퓨터의 하드웨어를 manage하는 소프트웨어이다.&lt;/li&gt;
&lt;li&gt;OS는 컴퓨터 유저와 컴퓨터 하드웨어간의 매개 역할을 수행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이해를 돕기 위해 우리는 컴퓨터 시스템이 어떻게 구성되어 있는지 알아야 한다. 크게 4가지 component로 구성되어 있는데, 하드웨어, 운영체제, 응용 프로그램, 그리고 유저 이다. 유저가 행하는 다양한 프로그래밍이 접근하는 프로그램은 컴파일러, 어셈블러, 텍스트 에디터, 데이터베이스 시스템 등 다양하다. 이러한 시스템 프로그래밍 혹은 어플리케이션 프로그래밍을 할때 운영체제와 통신하면, 운영체제가 대신 하드웨어에 접근하는 방식으로 구성되어 있다. 아래의 그림을 참고하자.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>백준 2667번 - 단지번호붙이기</title>
    <link href="https://jeongwookie.github.io/2021/12/02/programming/codingtest/dfs&amp;bfs/2-baekjoon-2667/"/>
    <id>https://jeongwookie.github.io/2021/12/02/programming/codingtest/dfs&amp;bfs/2-baekjoon-2667/</id>
    <published>2021-12-02T08:33:28.000Z</published>
    <updated>2021-12-08T08:56:33.496Z</updated>
    
    <content type="html"><![CDATA[<p>코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.</p><a id="more"></a><h2 id="백준-2667-단지번호붙이기"><a href="#백준-2667-단지번호붙이기" class="headerlink" title="백준 2667: 단지번호붙이기"></a>백준 2667: 단지번호붙이기</h2><p>문제 출처 : <a href="https://www.acmicpc.net/problem/2667" rel="external nofollow noopener noreferrer" target="_blank">https://www.acmicpc.net/problem/2667</a><br><img src="https://user-images.githubusercontent.com/25416425/144386584-c78c68dc-799e-495f-a92d-406ae9cb9cbd.png" alt="image"></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>시작점을 잡고, 해당 점에서 인접한 동서남북을 dfs 또는 bfs로 방문하면서 count하는 문제<br>시작 가능한 점은 지도에서 1로 표시된 구역이고, 여기서 시작하여 인접한 곳을 탐색하면 자연스럽게 단지가 정의된다.<br>탐색 도중 지도 밖으로 나가는 경우를 제외시켜 주어야 한다. </p><h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><p>[1] DFS<br>: 해당 좌표의 값이 1인 지점에서 시작하여 깊이 우선 탐색으로 단지를 정의할 수 있다. 재귀적으로 모든 인접한 구간을 방문한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[풀이 논리]</span><br><span class="line"><span class="number">1.</span> 해당 좌표가 지도 밖이면 <span class="literal">False</span></span><br><span class="line"><span class="number">2.</span> 해당 좌표에 집이 없으면 <span class="literal">False</span></span><br><span class="line"><span class="number">3.</span> 해당 좌표에 집이 있는 경우, 글로벌 변수인 house_count를 <span class="number">1</span> 올려주고,</span><br><span class="line"><span class="number">4.</span> 해당 좌표값을 <span class="number">0</span>으로 만들어줌 (다시 방문하지 않기 위해)</span><br><span class="line"><span class="number">5.</span> 그리고 상하좌우로 dfs를 수행하여 방문함</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;N<span class="number">-1</span> <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;N<span class="number">-1</span>: <span class="comment"># 지도 밖으로 나가면 False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> array[i][j] == <span class="number">0</span>: <span class="comment"># 집이 없으면 False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># 집이 있는 경우 True</span></span><br><span class="line">        array[i][j] = <span class="number">0</span> <span class="comment"># 방문 후 0으로 만듬</span></span><br><span class="line">        <span class="keyword">global</span> house_count</span><br><span class="line">        house_count += <span class="number">1</span> <span class="comment"># 글로별 변수에 해당 count를 누적시킴</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">4</span>): <span class="comment"># 인접한 곳을 재귀적으로 방문</span></span><br><span class="line">            nx, ny = i + dx[idx], j + dy[idx]</span><br><span class="line">            dfs(nx, ny)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys; readline = sys.stdin.readline</span><br><span class="line">    N = int(readline().strip())</span><br><span class="line">    array = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        array.append([int(i) <span class="keyword">for</span> i <span class="keyword">in</span> readline().strip()])</span><br><span class="line"></span><br><span class="line">    dx = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    dy = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">    house_count, total_count = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            <span class="keyword">if</span> dfs(i,j): <span class="comment"># dfs의 결과가 True인 경우 : (i,j)가 시작점 일때</span></span><br><span class="line">                ans.append(house_count)</span><br><span class="line">                house_count = <span class="number">0</span>  <span class="comment"># 단지가 종료되었으므로 초기화</span></span><br><span class="line">                total_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 결과 프린트</span></span><br><span class="line">    print(total_count)</span><br><span class="line">    [print(i) <span class="keyword">for</span> i <span class="keyword">in</span> sorted(ans)]</span><br></pre></td></tr></table></figure></p><p>[2] BFS<br>: 해당 좌표의 값이 1인 지점에서 시작하여 넓이 우선 탐색으로 단지를 정의할 수 있다. 큐를 사용하여 인접한 좌표를 한번에 탐색한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 집이 없는 곳은 방문하지 않음</span><br><span class="line"><span class="number">2.</span> 집이 있는 경우, queue를 만들고 방문 처리 후 반복문을 셋팅함</span><br><span class="line"><span class="number">3.</span> 반복문을 돌면서, 해당 좌표와 인접한 곳을 다 돌면서 확인함</span><br><span class="line"><span class="number">4.</span> 지도 밖을 넘어가지 않고, 해당 인접 좌표에 집이 있는 경우 houst_count를 올려줌.</span><br><span class="line"><span class="number">5.</span> 총 house_count를 리턴함. <span class="number">0</span>인 경우는 하나도 방문 못한 것이기 때문에 단지가 아님.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> array[i][j] == <span class="number">0</span>: <span class="comment"># 집이 없으면 False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    queue = deque([[i,j]]) <span class="comment"># 큐에 방문 좌표 넣기</span></span><br><span class="line">    array[i][j] = <span class="number">0</span> <span class="comment"># 방문 처리</span></span><br><span class="line">    house_count = <span class="number">1</span> <span class="comment"># 현재 방문한 곳부터 세어야 함.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        x, y = queue.popleft()</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            nx, ny = x + dx[idx], y + dy[idx]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;N <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;N: <span class="comment"># 지도 밖을 넘어가지 않고,</span></span><br><span class="line">                <span class="keyword">if</span> array[nx][ny] == <span class="number">1</span>: <span class="comment"># 해당 좌표에 집이 있는 경우</span></span><br><span class="line">                    queue.append([nx,ny]) <span class="comment"># 큐에 넣기</span></span><br><span class="line">                    array[nx][ny] = <span class="number">0</span> <span class="comment"># 방문 처리</span></span><br><span class="line">                    house_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> house_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys; readline = sys.stdin.readline</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    N = int(readline().strip())</span><br><span class="line">    array = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(N):</span><br><span class="line">        array.append([int(i) <span class="keyword">for</span> i <span class="keyword">in</span> readline().strip()])</span><br><span class="line"></span><br><span class="line">    dx = [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    dy = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>]</span><br><span class="line">    total_count = <span class="number">0</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">            result = bfs(i,j)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                ans.append(result)</span><br><span class="line">                total_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 결과 프린트</span></span><br><span class="line">    print(total_count)</span><br><span class="line">    [print(i) <span class="keyword">for</span> i <span class="keyword">in</span> sorted(ans)]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅱ. Programming" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/"/>
    
      <category term="코딩 테스트 문제 풀이" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/"/>
    
      <category term="DFS와 BFS" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/DFS%EC%99%80-BFS/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Codingtest" scheme="https://jeongwookie.github.io/tags/Codingtest/"/>
    
      <category term="Baekjoon" scheme="https://jeongwookie.github.io/tags/Baekjoon/"/>
    
      <category term="DFS&amp;BFS" scheme="https://jeongwookie.github.io/tags/DFS-BFS/"/>
    
  </entry>
  
  <entry>
    <title>OS공부 - 인트로</title>
    <link href="https://jeongwookie.github.io/2021/11/30/computerscience/operatingsystem/1-intro/"/>
    <id>https://jeongwookie.github.io/2021/11/30/computerscience/operatingsystem/1-intro/</id>
    <published>2021-11-30T07:18:33.000Z</published>
    <updated>2021-12-14T08:40:00.060Z</updated>
    
    <content type="html"><![CDATA[<p>운영 체제 과목을 본격적으로 들어가기 전, 인트로적인 내용을 정리했다. 앞으로 공룡책이라고 불리는 <em>Siberschatz et. al. 의 Operating System Concepts 10th Ed.</em>를 따라가면서 공부할 것이다.</p><p>운영 체제 (Operating System)는 컴퓨터 시스템을 운영하는 소프트웨어를 의미한다. 그러면 컴퓨터는 무엇인가? 무엇을 보고 컴퓨터라고 하나?<br>컴퓨터의 정의는 다음과 같이 되어 있다.</p><blockquote><p>A machine that processes the information</p></blockquote><a id="more"></a><p>즉, 정보를 처리하는 기계가 컴퓨터라는 것이다. 그러면 또 꼬리에 꼬리를 무는 질문이 있다. 정보란 무엇인가? 정보의 단위도 있는가?<br>다행히, 섀넌 선생님이 이에 대한 답을 마련해두었는데 이는 다음과 같다.<br>어떤 사건 x에 대해서 해당 사건의 정보량 I는, 해당 사건이 발생한 확률에 밑이 2인 로그를 취한 값의 negative로 하자!</p><p>이게 뭔소리냐, 일반적인 주사위를 상상해보자. 주사위는 1부터 6까지 나올 수 있다.<br>주사위를 하늘 위로 던졌다! 아직 뭐가 나올지 모르는 상황이고 사건은 발생하지 않았다. 이때 정보량은 없다.<br>주사위가 땅에 도달했다. 보니까 3이 나왔네? 이런 사건이 발생했고 이걸 나만 안다고 생각해보자.<br>이제 이 정보를 타인에게 전달해 주고 싶다. 이때, 전달되는 정보량이 얼마인가?<br>주사위를 던져서 3이 나올 확률은 알다시피 1/6이다. 섀넌의 정의에 따라서, 해당 값에 로그를 취하고 음수를 붙여주면 밑이 2인 log6이 바로 정보량이 된다. 이렇게 어떤 정보에 대해서 전달을 하고 싶을때는 반드시 해당 정보에 대한 quantitative한 정의가 동반되어야 한다. 컴퓨터는 정보를 처리하는 기계니깐..</p><p>이번에는 주사위가 아니라 동전을 던진다고 생각해보자. 동전은 앞과 뒤 이렇게 두가지 사건만 발생할 수 있고, 만약 사건 X가 동전의 앞이 나왔다고 정의되었을 때, 우리는 해당 정보의 전달량을 앞선 주사위의 예와 마찬가지로 계산할 수 있다. 밑이 2인 로그와 음수를 1/2에 취해주면…!! 1이 나왔다!</p><p>도량형을 정의할 때 해당 단위의 1을 어떤 기준으로 정의할 것인지는 대단히 중요한 문제이다. 우리는 이미 앞선 예로 정보량이 1이라는 것에 대해서 어떤 느낌인지 알았다. 바로 이것이 정보의 최소 단위인 <code>1 bit</code>을 정의하는 방식이다. bit은 binary digit의 약자이다.</p><p>그러면 이를 확장하면, 2비트는 동전 두개로 8비트는 동전 8개로 나타낼 수 있는 정보라고 이해할 수 있다. 8비트의 해당 가짓수는 2의 8승으로 이를 <code>1 byte</code>로 정의한다. 이런식으로 우리가 아는 1 메가바이트, 1 기가바이트, 1 테레바이트 등을 모두 이해할 수 있다.<br><img src="https://user-images.githubusercontent.com/25416425/144003917-54e6c816-19e3-4918-a04d-9f67172d1c59.png" alt="image"></p><p>자 정보의 단위는 알았다. 그러면 구체적으로 컴퓨터가 정보를 어떻게 처리하는지 궁금해진다. <strong>“정보의 처리”</strong> 라는 것은 정보의 상태를 0에서 1로 또는 1에서 0으로 바꾸는 것을 의미한다. 이는 NOT, AND, OR, XOR, NAND, NOR 이 여섯가지 논리 게이트를 통해서 이루어지는데 얘들을 집적 시켜서 바로 그 논리 회로를 만든다. 논리 게이트를 계속 집적시켜서 논리 회로가 점점 더 빽빽해지고 컴퓨터의 정보 처리 능력이 비약적으로 향상되는 것이다. 여기서 꼭 나오는 법칙이 있는데 그 유명한 무어의 법칙과 황의 법칙이다. </p><ul><li>무어의 법칙 : 집적도가 1년 6개월마다 두배씩 늘어남</li><li>황의 법칙 : 메모리가 1년에 두배씩 늘어남<br>해당 법칙들 까지만 이해하고, 실제로 정보를 산술연산 하는 방법이라던가 하는것은 컴퓨터 시스템 과목에서 상세하게 다루고 있기 때문에 넘어간다.</li></ul><p>그러면 이제 다시 컴퓨터로 돌아가자. 폰 노이만이 현대적 컴퓨터의 아버지라고 불리우는데, 그 이유는 그가 stored-program 방식의 컴퓨터를 설계했기 때문이다. 이게 뭐냐하면, 메모리에 프로그램을 저장해 놓고 쓰는 컴퓨터를 의미한다. 우리가 현재 사용하는 컴퓨터의 형태 아닌가! 이제 드디어 프로그램을 정의하는 단계까지 왔다.</p><p>프로그램이란, a set of instructions이다. 컴퓨터에게 어떤 task를 실행시키는 명령어들의 집합이 바로 프로그램인 것이다. 우리가 어떤 의도를 가지고 작성한 소스코드가 바로 프로그램이다. 이를 컴파일러가 컴파일하여 어셈블리어 단계를 지나 기계어로 번환되면 이는 곧 0과 1로 표현된 정보 이다. 우리는 중간 단계인 어셈블리어의 명령어를 보고 하드웨어가 어떻게 정보를 처리하고 있는지 파악할 수 있다.</p><p>프로그램이 무엇인지에 대해서 정의하였으니, 마지막으로 운영체제의 정의로 돌아가자.<br>운영체제는 컴퓨터에서 올타임으로 돌아가고 있는 프로그램이다. 구체적으로, 운영체제는 시스템 서비스들을 어플리케이션 프로그램에 제공해주는 역할을 수행하는데 이는 마치 API와 비슷하다. 사용자가 하드웨어를 직접 제어하지 않고 OS에 제어를 특정한 방법으로 요청하면, 이를 OS가 대신 처리해 주는 셈이다. 프로세스, 리소스, 유저 인터페이스 등을 관리하는 주체가 바로 운영체제! </p><h2 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h2><ul><li>1 bit는 0과 1 두가지 값만 가질 수 있는 측정 단위이다.</li><li>1 byte는 8개의 bit로 구성된 데이터의 양을 나타내는 단위이다.</li><li>무어의 법칙 : 회로의 집적도가 1년 6개월에 2배씩 늘어남</li><li>프로그램이란, 명령어들의 집합이다.</li><li>운영체제란, 시스템 콜과 같은 방법으로 사용자가 요청하면 이를 처리하여 하드웨어를 제어하는 기저 프로그램이라 할 수 있다.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;운영 체제 과목을 본격적으로 들어가기 전, 인트로적인 내용을 정리했다. 앞으로 공룡책이라고 불리는 &lt;em&gt;Siberschatz et. al. 의 Operating System Concepts 10th Ed.&lt;/em&gt;를 따라가면서 공부할 것이다.&lt;/p&gt;
&lt;p&gt;운영 체제 (Operating System)는 컴퓨터 시스템을 운영하는 소프트웨어를 의미한다. 그러면 컴퓨터는 무엇인가? 무엇을 보고 컴퓨터라고 하나?&lt;br&gt;컴퓨터의 정의는 다음과 같이 되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A machine that processes the information&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Ⅲ. CS Study" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/"/>
    
      <category term="Operating System" scheme="https://jeongwookie.github.io/categories/%E2%85%A2-CS-Study/Operating-System/"/>
    
    
      <category term="cs" scheme="https://jeongwookie.github.io/tags/cs/"/>
    
      <category term="os" scheme="https://jeongwookie.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>백준 1260번 - DFS와 BFS</title>
    <link href="https://jeongwookie.github.io/2021/11/29/programming/codingtest/dfs&amp;bfs/1-baekjoon-1260/"/>
    <id>https://jeongwookie.github.io/2021/11/29/programming/codingtest/dfs&amp;bfs/1-baekjoon-1260/</id>
    <published>2021-11-29T08:13:38.000Z</published>
    <updated>2021-11-30T05:55:40.525Z</updated>
    
    <content type="html"><![CDATA[<p>코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.</p><a id="more"></a><h2 id="백준-1260-DFS와-BFS"><a href="#백준-1260-DFS와-BFS" class="headerlink" title="백준 1260: DFS와 BFS"></a>백준 1260: DFS와 BFS</h2><p>문제 출처 : <a href="https://www.acmicpc.net/problem/1260" rel="external nofollow noopener noreferrer" target="_blank">https://www.acmicpc.net/problem/1260</a><br><img src="https://user-images.githubusercontent.com/25416425/143832293-337679f4-5b35-48b9-9a88-0cd132ccf1bf.png" alt="image"></p><h2 id="문제-설명"><a href="#문제-설명" class="headerlink" title="문제 설명"></a>문제 설명</h2><p>DFS와 BFS를 구현할 수 있는지 물어보는 직관적인 문제.<br>인풋을 받아서 적절한 graph 형태로 저장한 후, 이를 각각의 방식으로 순회하면서 출력하면 끝.<br><strong>어떤 두 정점 사이에 여러 개의 간선이 있을 수 있음</strong>에 주의하자.<br>큐나 스택을 활용할 때는 <code>from collections import deque</code>를 사용한다.</p><h2 id="문제-풀이"><a href="#문제-풀이" class="headerlink" title="문제 풀이"></a>문제 풀이</h2><p>[1] DFS<br>: 스택이나 재귀함수로 구현할 수 있다. 아래와 같은 플로우로 구현한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Recursive하게 구현하기]</span><br><span class="line"><span class="number">1.</span> 시작점을 먼저 방문 처리 후 해당 노드 출력</span><br><span class="line"><span class="number">2.</span> 인접 노드를 탐색하는데,</span><br><span class="line"><span class="number">3.</span> 해당 노드를 방문한 적이 없다면,</span><br><span class="line"><span class="number">4.</span> 재귀적으로 해당 노드를 방문함.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(graph, v, visited)</span>:</span></span><br><span class="line">    visited[v] = <span class="literal">True</span></span><br><span class="line">    print(v, end=<span class="string">' '</span>) <span class="comment"># 방문 처리한 노드를 출력</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> near_v <span class="keyword">in</span> graph[v]: <span class="comment"># 인접 노드에 대해서</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[near_v]: <span class="comment"># 해당 노드를 방문한 적이 없다면,</span></span><br><span class="line">            dfs(graph, near_v, visited) <span class="comment"># 재귀적으로 방문함</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[stack으로 구현하기]</span><br><span class="line"><span class="number">1.</span> stack을 만들고 시작점을 삽입</span><br><span class="line"><span class="number">2.</span> <span class="keyword">while</span>문을 써서 stack이 빌때까지 반복</span><br><span class="line"><span class="number">3.</span> 방문할 노드를 pop()을 통해 뽑음</span><br><span class="line"><span class="number">4.</span> 해당 노드를 방문한 적이 없다면, 방문 처리하고</span><br><span class="line"><span class="number">5.</span> 인접 노드를 stack에 extend()한다.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(graph, v, visited)</span>:</span></span><br><span class="line">    stack = deque([v]) <span class="comment"># stack에 시작점을 삽입</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> stack: <span class="comment"># stack이 빌 때까지 반복</span></span><br><span class="line">        visiting_node = stack.pop() <span class="comment"># stack에서 방문할 노드 선택</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[visiting_node]: <span class="comment"># 해당 노드를 방문한 적이 없다면,</span></span><br><span class="line">            visited[visiting_node] = <span class="literal">True</span> <span class="comment"># 방문 처리</span></span><br><span class="line">            print(visiting_node, end=<span class="string">' '</span>) <span class="comment"># 방문 완료한 노드 출력</span></span><br><span class="line">            stack.extend(sorted(graph[visiting_node], reverse=<span class="literal">True</span>)) <span class="comment"># 인접 노드를 stack에 넣는데 문제의 조건때문에 sort</span></span><br></pre></td></tr></table></figure><p>[2] BFS<br>: 큐를 통해 구현할 수 있다. 아래와 같은 플로우로 구현한다.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Queue를 통해 구현하기]</span><br><span class="line"><span class="number">1.</span> Queue를 만들고 시작점을 삽입 후</span><br><span class="line"><span class="number">2.</span> 해당 노드를 방문 처리함.</span><br><span class="line"><span class="number">3.</span> <span class="keyword">while</span>문을 사용하여 큐가 빌때까지 반복하는데,</span><br><span class="line"><span class="number">4.</span> 큐에서 이미 방문한 노드를 뽑고, 해당 노드에 대해서 인접한 노드를 전부 방문하는데</span><br><span class="line"><span class="number">5.</span> 인접 노드를 방문한 적이 없다면,</span><br><span class="line"><span class="number">6.</span> 해당 인접 노드를 큐에 넣고 방문 처리한다. (핵심)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(graph, v, visited)</span>:</span></span><br><span class="line">    queue = deque([v]) <span class="comment"># queue에 시작점을 삽입후</span></span><br><span class="line">    visited[v] = <span class="literal">True</span> <span class="comment"># 해당 노드를 방문 처리</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># queue가 빌 때까지 반복</span></span><br><span class="line">        visited_node = queue.popleft()</span><br><span class="line">        print(visited_node, end=<span class="string">' '</span>) <span class="comment"># 방문 완료한 노드를 출력</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> near_v <span class="keyword">in</span> graph[visited_node]: <span class="comment"># 인접 노드에 대해서</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[near_v]: <span class="comment"># 해당 노드를 방문한 적이 없다면</span></span><br><span class="line">                queue.append(near_v) <span class="comment"># 인접 노드를 queue에 넣고</span></span><br><span class="line">                visited[near_v] = <span class="literal">True</span> <span class="comment"># 해당 노드를 방문 처리</span></span><br></pre></td></tr></table></figure></p><h2 id="제출"><a href="#제출" class="headerlink" title="제출"></a>제출</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> sys; readline = sys.stdin.readline</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    N, M, V = map(int, readline().split()) <span class="comment"># 정점 갯수, 간선 갯수, 탐색 시작 정점 번호</span></span><br><span class="line">    graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N+<span class="number">1</span>)] <span class="comment"># 0번 인덱스를 버리기 위해 1 추가</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(M):</span><br><span class="line">        v1, v2 = map(int, readline().split())</span><br><span class="line">        graph[v1].append(v2)</span><br><span class="line">        graph[v2].append(v1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 정점 번호가 작은 것을 먼저 방문하기 위해 sort</span></span><br><span class="line">    graph = [sorted(_list) <span class="keyword">for</span> _list <span class="keyword">in</span> graph]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">    dfs(graph, V, visited)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># BFS</span></span><br><span class="line">    visited = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">    bfs(graph, V, visited)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;코테 풀이들은 대부분 길어서 더보기 클릭을 하지 않으면 보이지 않도록 해당 문구를 추가합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅱ. Programming" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/"/>
    
      <category term="코딩 테스트 문제 풀이" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/"/>
    
      <category term="DFS와 BFS" scheme="https://jeongwookie.github.io/categories/%E2%85%A1-Programming/%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4/DFS%EC%99%80-BFS/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Codingtest" scheme="https://jeongwookie.github.io/tags/Codingtest/"/>
    
      <category term="Baekjoon" scheme="https://jeongwookie.github.io/tags/Baekjoon/"/>
    
      <category term="DFS&amp;BFS" scheme="https://jeongwookie.github.io/tags/DFS-BFS/"/>
    
  </entry>
  
  <entry>
    <title>2021년의 근황</title>
    <link href="https://jeongwookie.github.io/2021/11/14/others/diary/11-my-recent-days-in-2021/"/>
    <id>https://jeongwookie.github.io/2021/11/14/others/diary/11-my-recent-days-in-2021/</id>
    <published>2021-11-14T12:14:29.000Z</published>
    <updated>2021-12-13T05:07:50.169Z</updated>
    
    <content type="html"><![CDATA[<p>블로그를 오랜만에 접속했습니다.<br>18년도에 블로그를 만들었을 때, 꾸준히 한달에 한번이라도 글을 쓰자 생각했었는데 지켜지지 않았네요 ㅠ.ㅠ<br>2020년의 나와 현재의 나를 비교하면서 되돌아보니 생각보다 이것저것 바뀐 것이 있습니다. 물론 시간이 너무 빨리 지나가는 것 같은 생각은 항상 하지만요.</p><a id="more"></a><p>현재 저는 분당에 있는 티맥스소프트에서 전문연구요원을 하고 있습니다. 시작한지 벌써 1년이 지났네요…<br>그 사이에 훈련소도 다녀오고, 훈련소 다녀온 시점부터 현재까지 약 7개월 이상 꾸준하게 헬스를 하고 있습니다.<br>과거에 저는 헬스를 정말 싫어하던 사람이더라구요 옛날 글들을 보니까 ㅋㅋㅋ 지금은 사람이 뭘 잘못먹었나 싶을 정도로 헬스에 집착(?)하고 있습니다. 운동 한번 제대로 시작해보자 생각하고 꾸준하게 생활로 가져가니까 되긴 되더라구요. 식단도 관리 하면서 주에 5~6회 헬스장에 퇴근하고 반드시 갑니다.</p><p>블로그를 다시 시작할려고 생각한 이유는, 회사에 익숙해지고 분당이란 곳에 충분히 익숙해졌다고 생각했기 때문입니다. 이제 또 다른 도약을 진지하게 준비해야 하는 시점이라고 생각이 들었어요. (사실 위기감입니다 이렇게 살아도 되나 현자타임이 강하게 왔습니다;;;)</p><p>저의 다음 스텝에 대한 진지한 고민을 병행하면서, 일단은 방향을 Data Scientist / ML Engineer 로 잡았습니다. 그리고 더 늦기 전에 Computer Science 교과목들을 제대로 짚고 넘어가야겠다고 생각했습니다. 이쪽 분야로 계속 들어가려면 CS공부는 필수적이고, 앒게 공부한 분들이나 학부때부터 전공했음에도 불구하고 당시 수업때 많이 놀아서(?) 까먹음을 후회하는 개발자들을 많이 보았습니다. 회사 다니면서 시간 쪼개서 공부하는 것이 쉽지는 않겠지만, 이직을 하고 더 deep dive하게 되면 점점 더 시간이 없어서 결국은 못하게 되지 않을까 하는 생각입니다.</p><p>다른 학부때부터 전공자들에 비해서 확실히 부족한 부분들이 있다는 점이 제 마음에 계속 응어리처럼 남아있었습니다. 회사에서 갑자기 java로 백엔드 서비스 개발을 맡았을 때도, DB에 대한 이해가 부족하여서 계속 구글링하거나 물어보는 수 밖에 없었죠 ㅠㅠ 이걸 해결하지 못하면, 운좋게 어디 다른 좋은 회사에 이직하게 된다 하더라도 결국은 끝에 가서 발목을 잡을 것 같습니다.</p><p>잡설이 길었는데, 이런 여러가지 생각으로 공부를 시작했고 공부한 내용들을 복습하기 위해 블로그에 기록을 하자는게 취지입니다. 덤으로 코테 문제들을 안풀어본지 대단히 오래되어서;;;; 이직을 하는데 문제가 있을 것이라 판단하여서 기본부터 다시 매일 조금씩 풀기로 결정했습니다. 요것도 복습이 필요한 문제의 경우에는 포스팅을 약간씩 해보려구요 :)</p><p>거품 다 빼고, 프로그래밍적 마인드 부터 알고리즘, 자료구조, 컴퓨터시스템, 운영체제, 네트워크, 데이터베이스 등 CS과목들을 쭉 다 읽을 계획을 가지고 있습니다. 주로 관련 전공서 읽기 + 해외 유명 대학 수업듣고 lab session 수행하는 방법으로 마치 다시 대학교 가서 수업 듣는 것처럼 생각하고 진행할 것 같아요.</p><p>구체적인 CS 공부 커리큘럼, 이직을 위한 준비 등 이런 정보들도 제가 마음을 다잡는 겸 포스팅 할수도 있습니다 ㅎㅎ 이직이 끝나면 할수도 있구요. 일단은 공부부터, 코드부터 짜고 해보겠습니다. 안녕.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;블로그를 오랜만에 접속했습니다.&lt;br&gt;18년도에 블로그를 만들었을 때, 꾸준히 한달에 한번이라도 글을 쓰자 생각했었는데 지켜지지 않았네요 ㅠ.ㅠ&lt;br&gt;2020년의 나와 현재의 나를 비교하면서 되돌아보니 생각보다 이것저것 바뀐 것이 있습니다. 물론 시간이 너무 빨리 지나가는 것 같은 생각은 항상 하지만요.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅹ. Others" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/"/>
    
      <category term="일기" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/%EC%9D%BC%EA%B8%B0/"/>
    
    
      <category term="Daily life" scheme="https://jeongwookie.github.io/tags/Daily-life/"/>
    
  </entry>
  
  <entry>
    <title>트위터 파헤치기 시리즈 두번째 - 한국어 전처리</title>
    <link href="https://jeongwookie.github.io/2020/04/29/datascience/twitter/3-analyze-tweet-series-2-preprocessing/"/>
    <id>https://jeongwookie.github.io/2020/04/29/datascience/twitter/3-analyze-tweet-series-2-preprocessing/</id>
    <published>2020-04-29T07:51:49.000Z</published>
    <updated>2021-11-21T11:21:46.905Z</updated>
    
    <content type="html"><![CDATA[<p>트위터 파헤치기 두번째 시리즈의 주제는 <strong>한국어 전처리</strong> 이다.<br>단순히 LDA 토픽 모델링을 하는 것에서부터 딥러닝 모델을 훈련시키는 것 까지 NLP와 관련된 전 과정에서 전처리는 필수적이다.<br>텍스트 데이터의 특성상 기본적으로 노이즈 (noise)가 많은 데이터에 속하기 때문이다. 다음과 같은 과정을 보통 진행한다.</p><ul><li>Tokenization : 문장을 하나의 기준을 가지고 자르는 것 (안녕하세요 -&gt; 안녕 / 하세요)</li><li>Stemming : 동사 및 형용사 등의 활용 형태를 원문으로 바꾸는 것 (잼따 -&gt; 재미 이다)</li><li>Noramlization : 표기가 다른 단어들을 통합하는 것 (입니닼ㅋㅋ -&gt; 입니다 ㅋㅋ)</li><li>Noise removal : 문장의 의미를 이해하는 데에 불필요한 부분을 제거하는 것 (특수문자, url 등)</li></ul><p>영어의 경우 <code>nltk</code> 라는 강력한 파이썬 패키지가 존재하여, 대부분의 우리가 원하는 전처리 함수들이 구현되어 있다.<br>그러나 한국어의 경우 Tokenization의 단위가 단어인지, 형태소인지, 자모인지, 아니면 그 외인지조차 아직까지 불명확한 부분이 있다. (현재도 연구중)<br>또한, Normalization이나 Stemming의 경우에도 <code>Konlpy</code>에 최근 포함된 <code>Okt</code> 클래스가 지원하지만 써본 결과 영어만큼 완벽하지는 않다.</p><p>그래서 본 포스트에서는 제일 general 한 토크나이저인 <code>Mecab</code>을 사용해서 그나마 reasonable한 방향으로 한국어 전처리를 진행해 보고자 한다. 현재도 계속 연구중이므로 완벽한 방법은 아니라는 것에 유의하자.</p><p><img src="https://user-images.githubusercontent.com/25416425/80573175-742c0680-8a3a-11ea-9a8d-940a8215b879.png" width="500"></p><a id="more"></a><h2 id="토크나이저-설치하기"><a href="#토크나이저-설치하기" class="headerlink" title="토크나이저 설치하기"></a>토크나이저 설치하기</h2><p>전처리를 시작하기 전, base 도구가 될 토크나이저 선정 및 설치는 필수적이다.<br>다양한 토크나이저가 있지만, 속도가 빠르고 비문에서도 적당히 잘 동작하는 <code>Mecab</code> 패키지를 본 포스트에서는 사용할 것이다.<br><code>Khaiii</code> 또는 <code>Soynlp</code>와 같은 최신 한국어 대응 패키지들을 사용하여도 무방하다.<br>심지어 한국어가 아닌 다른 나라 언어 (예: 이란어)를 전처리 하고 싶을 때에도 아래의 로직은 그대로 활용할 수 있다. 적절한 토크나이저만 선택해서 설치하자.</p><p>우리가 사용할 <code>Mecab</code>은 <a href="https://bitbucket.org/eunjeon/mecab-ko-dic/src/master/" rel="external nofollow noopener noreferrer" target="_blank">공식 홈페이지</a>에서 설치 방법을 확인할 수 있다. 상세한 설치 방법은 여기서는 다루지 않겠다. 총 3가지의 설치 과정을 모두 진행해야 한다는 것만 유의하자. </p><ul><li>Mecab-ko 설치하기 (source)</li><li>Mecab-ko-dic 설치하기 (사전)</li><li>Mecab-python3 설치하기 (파이썬 연동)</li></ul><p>포스트를 적는 도중 나 대신 <code>Mecab</code> 설치 방법에 대해 자세히 적어놓은 블로그를 발견했다. <a href="https://lsjsj92.tistory.com/491" rel="external nofollow noopener noreferrer" target="_blank">이수진 님의 블로그 - Mecab 설치</a> 을 참고해도 괜찮을 것 같다.</p><p>설치 완료 후 주피터 노트북에서 동작을 확인하자. 혹시나 <code>Konlpy</code>를 설치하지 않은 사용자라면 이 패키지는 한국어 처리의 기본이니 설치해 놓자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> konlpy.tag <span class="keyword">import</span> Mecab </span><br><span class="line"></span><br><span class="line">m = Mecab()</span><br><span class="line">m.pos(<span class="string">"일등이 아니여도 괜찮아"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print out</span></span><br><span class="line">&gt;&gt; [(<span class="string">'일등'</span>, <span class="string">'NNG'</span>),</span><br><span class="line"> (<span class="string">'이'</span>, <span class="string">'JKC'</span>),</span><br><span class="line"> (<span class="string">'아니'</span>, <span class="string">'VCN'</span>),</span><br><span class="line"> (<span class="string">'여도'</span>, <span class="string">'EC'</span>),</span><br><span class="line"> (<span class="string">'괜찮'</span>, <span class="string">'VA'</span>),</span><br><span class="line"> (<span class="string">'아'</span>, <span class="string">'EC'</span>)]</span><br></pre></td></tr></table></figure><h2 id="텍스트-클리닝"><a href="#텍스트-클리닝" class="headerlink" title="텍스트 클리닝"></a>텍스트 클리닝</h2><p>본격적으로 한국어 토크나이징을 진행하기 전, noise removal 파트부터 코드를 작성해 보자.</p><p><a href="https://jeongwookie.github.io/2020/04/23/200423-analyze-tweet-series-1-collect/">이전 포스트 - 트윗 수집하기</a>에서 수집했던 트윗을 예시로 텍스트 클리닝을 진행할 것이다.</p><p><img src="https://user-images.githubusercontent.com/25416425/80576775-bc4e2780-8a40-11ea-9f29-1d28ef486981.png" width="400"></p><p>위 그림은 트위터에서 직접 눈으로 볼 수 있는 트윗의 페이지를 캡쳐한 것이다. 그러나 우리가 수집한 데이터는 아래와 같이 생겼다.</p><p><img src="https://user-images.githubusercontent.com/25416425/80576974-0c2cee80-8a41-11ea-90b9-05aa40b5c625.png" width="700"></p><p>상당히 텍스트 데이터의 noise가 심한 것을 확인할 수 있다. 특수문자 및 URL이 텍스트 중간 중간에 섞여 있어 제대로 제거하지 않으면 이후 분석에 방해가 된다.</p><p>이제 텍스트 클리닝을 수행하는 코드를 실제로 작성해 보자. 주로 <code>regex</code> 문법을 활용할 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># Basic Cleaning Text Function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CleanText</span><span class="params">(readData, Num=False, Eng=False)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove Retweets </span></span><br><span class="line">    text = re.sub(<span class="string">'RT @[\w_]+: '</span>, <span class="string">''</span>, readData)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove Mentions</span></span><br><span class="line">    text = re.sub(<span class="string">'@[\w_]+'</span>, <span class="string">''</span>, text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove or Replace URL </span></span><br><span class="line">    text = re.sub(<span class="string">r"http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+"</span>, <span class="string">' '</span>, text) <span class="comment"># http로 시작되는 url</span></span><br><span class="line">    text = re.sub(<span class="string">r"[-a-zA-Z0-9@:%._\+~#=]&#123;1,256&#125;\.[a-zA-Z0-9()]&#123;2,6&#125;\b([-a-zA-Z0-9()@:%_\+.~#?&amp;//=]*)"</span>, <span class="string">' '</span>, text) <span class="comment"># http로 시작되지 않는 url</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Remove Hashtag</span></span><br><span class="line">    text = re.sub(<span class="string">'[#]+[0-9a-zA-Z_]+'</span>, <span class="string">' '</span>, text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove Garbage Words (ex. &amp;lt, &amp;gt, etc)</span></span><br><span class="line">    text = re.sub(<span class="string">'[&amp;]+[a-z]+'</span>, <span class="string">' '</span>, text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove Special Characters</span></span><br><span class="line">    text = re.sub(<span class="string">'[^0-9a-zA-Zㄱ-ㅎ가-힣]'</span>, <span class="string">' '</span>, text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Remove newline</span></span><br><span class="line">    text = text.replace(<span class="string">'\n'</span>,<span class="string">' '</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> Num <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Remove Numbers</span></span><br><span class="line">        text = re.sub(<span class="string">r'\d+'</span>,<span class="string">' '</span>,text)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> Eng <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># Remove English </span></span><br><span class="line">        text = re.sub(<span class="string">'[a-zA-Z]'</span> , <span class="string">' '</span>, text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove multi spacing &amp; Reform sentence</span></span><br><span class="line">    text = <span class="string">' '</span>.join(text.split())</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> text</span><br></pre></td></tr></table></figure><p>코드가 좀 복잡하다. 그래도 위 코드는 내가 트윗을 연구 대상으로 삼으면서 여러모로 트위터에 맞게 세팅한 것이니 따라오길 바란다.</p><p>위 코드가 하는 역할은 최대한 원문을 살리면서 분석에 불필요한 (토픽을 이해하는 데에 필요하지 않은) 부분을 제거하는 것이다.<br>예를 들어서 트위터에서 리트윗 시 텍스트 앞에 RT @user_screenname 과 같은 형태의 텍스트가 붙게 되는데, 이런 부분만을 제거 한다던지 하는 것이다.</p><p>트위터에서 URL은 대단히 자주 보이는데, 우리가 분석할 때에는 필요치 않은 정보이다. 위 코드는 여러가지 경우의 URL을 찾아서 제거하게 해 놓았다. (Regex URL 매칭 후 제거)<br>또한 Boolean 을 사용해서 숫자와 영어에 대해서 옵션을 만들어 놓았는데, 이는 경우에 따라 숫자와 영어를 찾아서 모두 제거하고 한국어만 분석하는 것이 편하기 때문이다. 그러나 기본값은 <code>False</code>로 해 두었는데, 이를 활성화할 경우 KBS, CNN, 40개국, G20 과 같은 의미가 존재하는 단어들도 제거되기 때문이다.</p><p>트위터를 분석하지 않을 경우, 위 코드 중에서 일부만 사용하고 나머지는 주석 처리하면 편하게 적용할 수 있을 것이다. (요렇게 한국어 클리닝 코드를 통으로 올려놓은 블로그는 본적이 없어서.. 지금까지 나도 갑갑했다)</p><p>설명이 길었다. 위 코드를 앞의 예시 트윗에 적용해 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SAMPLE_TEXT = <span class="string">"&lt;🚨코로나19 가짜뉴스 팩트체크&gt;\n\n신천지가 기성교회에 가서 코로나를 전파하라고 했다??!\n\n- 사실 무근입니다. \n신천지는 2월 18일 부터 전국 교회를 폐쇄하고 온라인\n예배로 전환하였습니다.\n\n#온라인예배\n#가짜뉴스_이제그만\n#신천지_팩트체크 pic.twitter.com/Dppie6iean"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Before cleaning text:\n<span class="subst">&#123;SAMPLE_TEXT&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">f"After cleaning text:\n<span class="subst">&#123;CleanText(SAMPLE_TEXT)&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">"\n"</span>)</span><br><span class="line">print(<span class="string">f"After cleaning text when Num is True:\n<span class="subst">&#123;CleanText(SAMPLE_TEXT, Num=<span class="literal">True</span>)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/80684237-53c67f80-8b00-11ea-865a-16651c612b8e.png" width="800"></p><p>깔끔하게 텍스트 클리닝이 완료된 것을 확인할 수 있다.</p><h2 id="텍스트-토크나이징"><a href="#텍스트-토크나이징" class="headerlink" title="텍스트 토크나이징"></a>텍스트 토크나이징</h2><p>이번에는 위 텍스트 클리닝 코드를 포함한 한국어 토크나이징을 진행해 보겠다.<br>의미를 내포하고 있는 단위로 잘라서 토픽모델링을 시도하기 전 단계로 이해하면 된다.</p><p><code>Mecab</code> 토크나이저는 POS 태깅을 지원하기 때문에, 태깅 상태를 보고 조사나 어미 등 의미를 파악하는 데에 불필요한 부분들을 제거한다. </p><p>추가적으로 위 프로세스에서 걸러지지 않은 Stopwords 를 추가로 거를 수도 있지만 이는 데이터에 따라서 커스터마이즈가 많이 이루어져야 하기에, 본 포스트에서는 생략했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> konlpy.tag <span class="keyword">import</span> Mecab </span><br><span class="line"></span><br><span class="line"><span class="comment"># Preprocessing code with Mecab</span></span><br><span class="line">mecab = Mecab(dicpath=<span class="string">"/usr/local/lib/mecab/dic/mecab-ko-dic"</span>) <span class="comment"># Mecab User Dic Path</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocessing_mecab</span><span class="params">(readData)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#### Clean text</span></span><br><span class="line">    sentence = CleanText(readData)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#### Tokenize</span></span><br><span class="line">    morphs = mecab.pos(sentence)</span><br><span class="line">    </span><br><span class="line">    JOSA = [<span class="string">"JKS"</span>, <span class="string">"JKC"</span>, <span class="string">"JKG"</span>, <span class="string">"JKO"</span>, <span class="string">"JKB"</span>, <span class="string">"JKV"</span>, <span class="string">"JKQ"</span>, <span class="string">"JX"</span>, <span class="string">"JC"</span>] <span class="comment"># 조사</span></span><br><span class="line">    SIGN = [<span class="string">"SF"</span>, <span class="string">"SE"</span>, <span class="string">"SSO"</span>, <span class="string">"SSC"</span>, <span class="string">"SC"</span>, <span class="string">"SY"</span>] <span class="comment"># 문장 부호</span></span><br><span class="line">    TERMINATION = [<span class="string">"EP"</span>, <span class="string">"EF"</span>, <span class="string">"EC"</span>, <span class="string">"ETN"</span>, <span class="string">"ETM"</span>] <span class="comment"># 어미</span></span><br><span class="line">    SUPPORT_VERB = [<span class="string">"VX"</span>] <span class="comment"># 보조 용언</span></span><br><span class="line">    NUMBER = [<span class="string">"SN"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Remove JOSA, EOMI, etc</span></span><br><span class="line">    morphs[:] = (morph <span class="keyword">for</span> morph <span class="keyword">in</span> morphs <span class="keyword">if</span> morph[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> JOSA+SIGN+TERMINATION+SUPPORT_VERB)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Remove length-1 words  </span></span><br><span class="line">    morphs[:] = (morph <span class="keyword">for</span> morph <span class="keyword">in</span> morphs <span class="keyword">if</span> <span class="keyword">not</span> (len(morph[<span class="number">0</span>]) == <span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Remove Numbers</span></span><br><span class="line">    morphs[:] = (morph <span class="keyword">for</span> morph <span class="keyword">in</span> morphs <span class="keyword">if</span> morph[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> NUMBER)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># Result pop-up</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> morph <span class="keyword">in</span> morphs:</span><br><span class="line">        result.append(morph[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>Mecab</code>을 불러올 때 사용한 <code>dicpath</code> 옵션은 등록된 사용자 사전을 사용하고 싶을때 적는 것이다. 사용하지 않을 경우 지워버리면 된다.</p><p>코드의 흐름은 먼저 앞의 섹션에서 작성했던 <code>CleanText()</code> 함수를 사용해 텍스트 클리닝을 진행하고, 이후 <code>Mecab</code> 토크나이저를 사용해서 토큰화한다. 그리고 POS 태깅된 정보를 활용해서 의미가 없는 단어들을 삭제한다. 추가적으로, 잘랐을 때 길이가 1인 (글자 1개) 단어는 의미를 알기 어려워 제거하였다.</p><p><code>Mecab</code> 토크나이저의 POS 태깅 정보를 보다 자세히 알고 싶다면 <a href="http://kkma.snu.ac.kr/documents/?doc=postag" rel="external nofollow noopener noreferrer" target="_blank">한글 형태소 품사 태그표</a>를 참고하자.</p><p>이제 위 코드를 실행시켜 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SAMPLE_TEXT = <span class="string">"&lt;🚨코로나19 가짜뉴스 팩트체크&gt;\n\n신천지가 기성교회에 가서 코로나를 전파하라고 했다??!\n\n- 사실 무근입니다. \n신천지는 2월 18일 부터 전국 교회를 폐쇄하고 온라인\n예배로 전환하였습니다.\n\n#온라인예배\n#가짜뉴스_이제그만\n#신천지_팩트체크 pic.twitter.com/Dppie6iean"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN!</span></span><br><span class="line">preprocessing_mecab(SAMPLE_TEXT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'코로나'</span>,</span><br><span class="line"> <span class="string">'가짜'</span>,</span><br><span class="line"> <span class="string">'뉴스'</span>,</span><br><span class="line"> <span class="string">'팩트체크'</span>,</span><br><span class="line"> <span class="string">'신천지'</span>,</span><br><span class="line"> <span class="string">'기성'</span>,</span><br><span class="line"> <span class="string">'교회'</span>,</span><br><span class="line"> <span class="string">'코로나'</span>,</span><br><span class="line"> <span class="string">'전파'</span>,</span><br><span class="line"> <span class="string">'무근'</span>,</span><br><span class="line"> <span class="string">'입니다'</span>,</span><br><span class="line"> <span class="string">'신천지'</span>,</span><br><span class="line"> <span class="string">'전국'</span>,</span><br><span class="line"> <span class="string">'교회'</span>,</span><br><span class="line"> <span class="string">'폐쇄'</span>,</span><br><span class="line"> <span class="string">'온라인'</span>,</span><br><span class="line"> <span class="string">'예배'</span>,</span><br><span class="line"> <span class="string">'전환'</span>,</span><br><span class="line"> <span class="string">'온라인'</span>,</span><br><span class="line"> <span class="string">'예배'</span>,</span><br><span class="line"> <span class="string">'가짜'</span>,</span><br><span class="line"> <span class="string">'뉴스'</span>,</span><br><span class="line"> <span class="string">'이제'</span>,</span><br><span class="line"> <span class="string">'그만'</span>,</span><br><span class="line"> <span class="string">'신천지'</span>,</span><br><span class="line"> <span class="string">'팩트체크'</span>]</span><br></pre></td></tr></table></figure><p>깔끔하게 토크나이징이 완료된 것을 확인할 수 있다. 읽어보면 의미도 잘 파악이 된다.<br>이제 위 코드들을 바탕으로, 다음 포스트에서는 LDA 토픽 모델링 및 간단한 워드 클라우드 만들기를 해볼 것이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;트위터 파헤치기 두번째 시리즈의 주제는 &lt;strong&gt;한국어 전처리&lt;/strong&gt; 이다.&lt;br&gt;단순히 LDA 토픽 모델링을 하는 것에서부터 딥러닝 모델을 훈련시키는 것 까지 NLP와 관련된 전 과정에서 전처리는 필수적이다.&lt;br&gt;텍스트 데이터의 특성상 기본적으로 노이즈 (noise)가 많은 데이터에 속하기 때문이다. 다음과 같은 과정을 보통 진행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tokenization : 문장을 하나의 기준을 가지고 자르는 것 (안녕하세요 -&amp;gt; 안녕 / 하세요)&lt;/li&gt;
&lt;li&gt;Stemming : 동사 및 형용사 등의 활용 형태를 원문으로 바꾸는 것 (잼따 -&amp;gt; 재미 이다)&lt;/li&gt;
&lt;li&gt;Noramlization : 표기가 다른 단어들을 통합하는 것 (입니닼ㅋㅋ -&amp;gt; 입니다 ㅋㅋ)&lt;/li&gt;
&lt;li&gt;Noise removal : 문장의 의미를 이해하는 데에 불필요한 부분을 제거하는 것 (특수문자, url 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;영어의 경우 &lt;code&gt;nltk&lt;/code&gt; 라는 강력한 파이썬 패키지가 존재하여, 대부분의 우리가 원하는 전처리 함수들이 구현되어 있다.&lt;br&gt;그러나 한국어의 경우 Tokenization의 단위가 단어인지, 형태소인지, 자모인지, 아니면 그 외인지조차 아직까지 불명확한 부분이 있다. (현재도 연구중)&lt;br&gt;또한, Normalization이나 Stemming의 경우에도 &lt;code&gt;Konlpy&lt;/code&gt;에 최근 포함된 &lt;code&gt;Okt&lt;/code&gt; 클래스가 지원하지만 써본 결과 영어만큼 완벽하지는 않다.&lt;/p&gt;
&lt;p&gt;그래서 본 포스트에서는 제일 general 한 토크나이저인 &lt;code&gt;Mecab&lt;/code&gt;을 사용해서 그나마 reasonable한 방향으로 한국어 전처리를 진행해 보고자 한다. 현재도 계속 연구중이므로 완벽한 방법은 아니라는 것에 유의하자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/80573175-742c0680-8a3a-11ea-9a8d-940a8215b879.png&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="트위터 데이터 분석하기" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%ED%8A%B8%EC%9C%84%ED%84%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Twitter" scheme="https://jeongwookie.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>트위터 파헤치기 시리즈 첫번째 - 수집하기</title>
    <link href="https://jeongwookie.github.io/2020/04/23/datascience/twitter/2-analyze-tweet-series-1-collect/"/>
    <id>https://jeongwookie.github.io/2020/04/23/datascience/twitter/2-analyze-tweet-series-1-collect/</id>
    <published>2020-04-23T08:38:46.000Z</published>
    <updated>2021-11-21T11:21:38.807Z</updated>
    
    <content type="html"><![CDATA[<p>트위터 데이터를 주로 수집해서 사용하다 보니, 너무 관련된 포스트를 여러개 쓰는것 같지만..<br>많은 분들이 댓글 혹은 메일로도 연락이 오셔서 문의하시는 부분이 있어 이 기회에 정리해 보고자 한다.</p><p>이름하여 <strong>트위터 파헤치기 시리즈!</strong> 수집부터 시작해서 한국어 전처리, 워드 클라우드 시각화 및 클러스터링 시 적절한 하이퍼 파라미터 설정 등 분석 단계까지 조금씩 정리해 보고자 한다.</p><p>예시 주제로 요즘 우리들을 괴롭히는 <strong>코로나 바이러스</strong> 에 대해서 트위터를 살펴보는 것으로 정했다.</p><p>지금까지 트위터 수집 방법에 대해서 꽤 여러 포스트를 썼었는데, 지금까지 다루지 않은 방법으로 시도하고자 한다. 수집 방법을 많이 알면 알수록 좋으니까! </p><p><img src="https://user-images.githubusercontent.com/25416425/80474558-8ea2a900-8982-11ea-99b0-e1cef6218e03.png" width="500"></p><a id="more"></a><h2 id="수집-도구-정하기"><a href="#수집-도구-정하기" class="headerlink" title="수집 도구 정하기"></a>수집 도구 정하기</h2><p>이번에 트위터 수집에 사용할 패키지는 <code>twint</code> 라는 친구이다.<br>(github page : <a href="https://github.com/twintproject/twint" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/twintproject/twint</a>)</p><p>무료로 사용할 수 있고, 트위터 개발자 등록 과정이 필요가 없어서 간단하게 트랜드나 토픽을 알고 싶을때 사용하곤 했다.</p><p>돈 내고 쓰는 것이 아니기 때문에 조금씩 불편한 점들이 있다. 그러나 현존하는 무료 파이썬 패키지 중에 가장 잘 작동하는 트위터 크롤링 패키지가 아닐까 싶다.</p><p>full-archive 트위터 데이터가 필요한 연구자라면 본 패키지는 불필요하다. Premium API를 결제해서 사용하도록 하자. 본인이 시도해본 결과 프리미엄에 비해 10~20%의 데이터밖에 크롤링하지 못한다.</p><p>그러나, 하루에 어떤 토픽이 이슈가 되었고 전반적인 트랜드를 알고 싶은 사용자라면 이것으로 충분하다.</p><p>아래부터 코드는 주피터 노트북으로 열어서 실행하는 것을 기본으로 전제하고 작성한다. <code>twint</code>를 설치부터 해주자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># python 3.6 </span><br><span class="line"># install twint package</span><br><span class="line">!pip install --user --upgrade -e git+https://github.com/twintproject/twint.git@origin/master#egg=twint</span><br></pre></td></tr></table></figure><p>깃허브 홈페이지를 들어가보면 pip 설치 이외에도 설치 방법이 다양하게 나와있다. (Python 3.6 기준)</p><h2 id="파라미터-설정하기"><a href="#파라미터-설정하기" class="headerlink" title="파라미터 설정하기"></a>파라미터 설정하기</h2><p><code>twint</code> 패키지는 거의 대부분의 Twitter API 가 지원하는 옵션을 동일하게 지원한다. 자세한 사용법은 본 포스트에서는 다루지 않을 생각이다. wiki를 읽어보면 혼자서 할 수 있도록 설명이 잘 되어 있기 때문이다.</p><p>본 포스트의 목적은 <strong>코로나 바이러스</strong> 에 관한 트윗을 수집하는 것이므로, 여기에 초점을 맞춰서 파라미터를 설정해 보겠다. 설정하면서 등장하는 <code>twint</code> 옵션에 대해서는 간단하게 설명을 달아놓는 것으로.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> twint</span><br><span class="line">c = twint.Config() <span class="comment"># twint config 선언</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameter setting</span></span><br><span class="line">c.Limit = <span class="number">50</span></span><br><span class="line">c.Search = <span class="string">'코로나 OR 우한 폐렴'</span></span><br><span class="line">c.Since = <span class="string">'2020-04-23'</span></span><br><span class="line">c.Until = <span class="string">'2020-04-24'</span></span><br><span class="line">c.Output = <span class="string">'covid19_sample_tweet.json'</span></span><br><span class="line">c.Popular_tweets = <span class="literal">True</span></span><br><span class="line">c.Store_json = <span class="literal">True</span></span><br><span class="line">c.Hide_output = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>옵션이 생각보다 많다.. 위의 코드에 사용된 옵션에 대해서 하나하나 알아보자.</p><ul><li>Limit: 총 수집할 트윗의 수를 의미 (모든 트윗을 수집하고 싶다면 옵션을 제거)</li><li>Search: 수집할 트윗의 키워드를 입력, <strong>Exact Match</strong>를 원하면 쌍따옴표를 사용<br>(ex. ‘코로나 OR “우한 폐렴”‘ 으로 입력할 경우, 정확히 우한 폐렴 이라는 단어를 모두 포함하는 트윗만 수집됨)</li><li>Since, Until: 수집을 원하는 기간 범위 (끝은 포함하지 않음)</li><li>Output: 트윗을 수집 후 저장할 때 파일 이름</li><li>Popular_tweets: <code>True</code>일 때 트위터 탭 중 Polular을 의미, <code>False</code>의 경우 Recent을 의미</li><li>Store_json: 저장 시 JSON 포맷으로</li><li>Hide_output: <code>True</code>일 때 주피터 노트북 콘솔에 output이 출력되는 옵션을 끔</li></ul><p>더 원하는 옵션이 있거나, 설명을 보고도 잘 이해하기 어렵다면 <a href="https://github.com/twintproject/twint/wiki/Configuration" rel="external nofollow noopener noreferrer" target="_blank">공식 홈페이지</a>의 설명을 참고하자.</p><h2 id="트위터-수집하기"><a href="#트위터-수집하기" class="headerlink" title="트위터 수집하기"></a>트위터 수집하기</h2><p>자, 설정은 끝났다. 이제 위에서 설정한 <code>twint</code>을 실행시켜 볼 것이다. 아래의 코드를 입력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twint.run.Search(c)</span><br></pre></td></tr></table></figure><p>위의 옵션에서 나는 “트위터에서 코로나 또는 우한 폐렴을 포함하는 트윗을 2020년 4월 23일 (UTC), Popular 탭 기준으로 50개만 수집해줘” 를 주문했다.</p><p>제대로 실행되었다면, working directory에 <code>covid19_sample_tweet.json</code> 파일이 생성되었을 것이다. 뜯어서 살펴보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_json(<span class="string">'covid19_sample_tweet.json'</span>, lines=<span class="literal">True</span>)</span><br><span class="line">df[[<span class="string">"created_at"</span>, <span class="string">"id"</span>, <span class="string">"tweet"</span>, <span class="string">"retweets_count"</span>]].head() <span class="comment"># 편의상 4개의 칼럼만 출력</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/80477180-79c81480-8986-11ea-96f3-5edd1718aaaa.png" width="750"></p><p>위와 같이 4월 23일의 트윗이 잘 수집되었음을 확인할 수 있다.</p><h2 id="크롤러-만들기"><a href="#크롤러-만들기" class="headerlink" title="크롤러 만들기"></a>크롤러 만들기</h2><p>위까지 잘 따라왔다면 <code>twint</code>를 사용해서 하루 단위의 트윗을 어떻게 모으는지 알았을 것이다.<br>이제 loop를 구성해서, 주어진 기간 내 특정 트윗을 모두 수집하도록 코드를 구성해 보자.<br>이쯤 되면 트위터 크롤러라고 이름을 붙여도 될 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import packages</span></span><br><span class="line"><span class="keyword">import</span> twint</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> mkdir, path</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># Valid Directory Naming Function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_name</span><span class="params">(term)</span>:</span></span><br><span class="line">    cleaned = re.sub(<span class="string">'[^0-9a-zA-Zㄱ-ㅎ가-힣]'</span>, <span class="string">''</span>, term) <span class="comment"># 특수문자 제거</span></span><br><span class="line">    <span class="keyword">return</span> cleaned</span><br><span class="line"></span><br><span class="line"><span class="comment"># Twint Search Function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twint_search</span><span class="params">(dirname, searchterm, since, until, json_name, limit)</span>:</span></span><br><span class="line"></span><br><span class="line">    c = twint.Config()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Parameter setting</span></span><br><span class="line">    c.Limit = limit</span><br><span class="line">    c.Search = searchterm</span><br><span class="line">    c.Since = since</span><br><span class="line">    c.Until = until</span><br><span class="line">    c.Hide_output = <span class="literal">True</span></span><br><span class="line">    c.Store_json = <span class="literal">True</span></span><br><span class="line">    c.Output = json_name</span><br><span class="line">    c.Debug = <span class="literal">True</span></span><br><span class="line">    c.Resume = <span class="string">f'<span class="subst">&#123;dirname&#125;</span>/save_endpoint/save_endpoint_<span class="subst">&#123;since&#125;</span>.txt'</span></span><br><span class="line">    c.Popular_tweets = <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        twint.run.Search(c)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> (KeyboardInterrupt, SystemExit):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        print(<span class="string">f"Problem with <span class="subst">&#123;since&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Loop Function, Default number of tweet is 50</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twint_loop</span><span class="params">(searchterm, since, until, limit=<span class="number">50</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line">    dirname = clean_name(searchterm)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Create target directory</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        mkdir(dirname)</span><br><span class="line">        mkdir(<span class="string">f'<span class="subst">&#123;dirname&#125;</span>/save_endpoint'</span>)</span><br><span class="line">        print(<span class="string">"Directory"</span> , dirname ,  <span class="string">"Created "</span>)</span><br><span class="line">    <span class="keyword">except</span> FileExistsError:</span><br><span class="line">        print(<span class="string">"Directory"</span> , dirname ,  <span class="string">"already exists"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Loop </span></span><br><span class="line">    daterange = pd.date_range(since, until)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> start_date <span class="keyword">in</span> daterange:</span><br><span class="line"></span><br><span class="line">        since = start_date.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">        until = (start_date + timedelta(days=<span class="number">1</span>)).strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line"></span><br><span class="line">        json_name = <span class="string">""</span>.join(since.split(<span class="string">"-"</span>)) + <span class="string">".json"</span></span><br><span class="line">        json_name = path.join(dirname, json_name)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">f'Getting <span class="subst">&#123;since&#125;</span> '</span>)</span><br><span class="line">        twint_search(dirname, searchterm, since, until, json_name, limit)</span><br></pre></td></tr></table></figure><p>조금 함수의 형태들이 마음에 들지 않지만, 작동은 잘 한다.<br>따로 값을 지정하지 않으면 기본적으로 각 날짜에 대해 50개의 트윗만 가져오도록 설정했다.<br>50개의 트윗을 시간 순서대로 가져오고 싶다면 옵션 중 <code>Popular_tweets</code>을 <code>False</code>로 지정하면 된다.</p><p>위의 섹션에서 다루지 않은 옵션이 있는데, <code>Debug</code> 와 <code>Resume</code>이다. 이는 대량의 트윗을 수집할 때 <code>twint</code>가 트위터 서버 측의 공격적인 크롤링 방지로 인해 TimeoutError를 발생시키기 때문에, 중간 저장 포인트를 만들기 위해 설정한 것이다.</p><p>일단 실행 고고!</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Keyword = <span class="string">'코로나 OR 우한 폐렴'</span></span><br><span class="line">twint_loop(Keyword, <span class="string">'2020-04-23'</span>, <span class="string">'2020-04-25'</span>, limit=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 실행 화면</span></span><br><span class="line">&gt;&gt; Directory 코로나OR우한폐렴 Created</span><br><span class="line">&gt;&gt; Getting <span class="number">2020</span><span class="number">-04</span><span class="number">-23</span> </span><br><span class="line">&gt;&gt; Getting <span class="number">2020</span><span class="number">-04</span><span class="number">-24</span> </span><br><span class="line">&gt;&gt; Getting <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span></span><br></pre></td></tr></table></figure><p>위와 같이 2020년 4월 23일부터 25일까지 트윗이 잘 수집됨을 확인할 수 있다.</p><p>Limit을 -1로 설정하면 조건을 만족하는 모든 트윗을 가져오게 되는데, 경우에 따라 몇 시간에서 몇십 시간이 소요될 수도 있다. (covid19와 같은 search 조건을 입력하면 그렇게 된다..)</p><p>그리고 너무 오랫동안 크롤러가 작동하게 되면 알수 없는 이유로 오류를 일으키는 경우가 간간히 존재한다. 경험적으로 크롤러가 끊어지는 부분들을 많이 보완한 코드가 위의 코드인데.. 문제들을 완전히 해결하고 싶다면 유료 버전을 검토해 보자.</p><p>수집된 내용을 확인해 볼까?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># Saved files path</span></span><br><span class="line">DATA_DIR = Path(<span class="string">f"./<span class="subst">&#123;clean_name(Keyword)&#125;</span>"</span>) <span class="comment"># 저장된 파일 디렉토리 정보</span></span><br><span class="line">json_files = [pos_json <span class="keyword">for</span> pos_json <span class="keyword">in</span> os.listdir(DATA_DIR) <span class="keyword">if</span> pos_json.endswith(<span class="string">'.json'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Data load</span></span><br><span class="line">df_list= []</span><br><span class="line"><span class="keyword">for</span> file_name <span class="keyword">in</span> tqdm(json_files):</span><br><span class="line">    temp_df = pd.read_json(DATA_DIR / file_name, lines=<span class="literal">True</span>)</span><br><span class="line">    df_list.append(temp_df)</span><br><span class="line">    </span><br><span class="line">df = pd.concat(df_list, sort=<span class="literal">False</span>)</span><br><span class="line">df[[<span class="string">"created_at"</span>, <span class="string">"id"</span>, <span class="string">"tweet"</span>, <span class="string">"retweets_count"</span>]].tail() <span class="comment"># 편의상 4개의 칼럼만 출력</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/80562211-05db4a00-8a22-11ea-973a-8416eff25eab.png" width="750"></p><p>수집이 잘 이루어졌음을 확인할 수 있다.</p><p>또한 위의 코드에는 여러개의 JSON 파일을 한번에 읽는 방법도 포함되어 있다.<br>하나의 JSON 파일에 너무 많은 트윗이 포함되어 있다면 읽는 데에도 시간이 오래 걸리니 유의하자.<br>통째로 묶어서 <code>df</code>에 저장하도록 되어 있는데, 트윗의 수가 몇 백만개가 넘어가면 Memory Error가 발생할 수 있다.<br>얼마나 읽어졌는지 눈으로 확인하기 위해 <code>tqdm</code>을 추가하였다. 오류가 난다면 제거해도 상관없다.</p><p>다음 포스트에서는 위와 같은 방법으로 수집한 트윗에 대해 한국어 NLP에서 가장 고충을 겪고 있는 점 중 하나인 전처리 (preprocessing)에 대해 다루어 볼 계획이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;트위터 데이터를 주로 수집해서 사용하다 보니, 너무 관련된 포스트를 여러개 쓰는것 같지만..&lt;br&gt;많은 분들이 댓글 혹은 메일로도 연락이 오셔서 문의하시는 부분이 있어 이 기회에 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;이름하여 &lt;strong&gt;트위터 파헤치기 시리즈!&lt;/strong&gt; 수집부터 시작해서 한국어 전처리, 워드 클라우드 시각화 및 클러스터링 시 적절한 하이퍼 파라미터 설정 등 분석 단계까지 조금씩 정리해 보고자 한다.&lt;/p&gt;
&lt;p&gt;예시 주제로 요즘 우리들을 괴롭히는 &lt;strong&gt;코로나 바이러스&lt;/strong&gt; 에 대해서 트위터를 살펴보는 것으로 정했다.&lt;/p&gt;
&lt;p&gt;지금까지 트위터 수집 방법에 대해서 꽤 여러 포스트를 썼었는데, 지금까지 다루지 않은 방법으로 시도하고자 한다. 수집 방법을 많이 알면 알수록 좋으니까! &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/80474558-8ea2a900-8982-11ea-99b0-e1cef6218e03.png&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="트위터 데이터 분석하기" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%ED%8A%B8%EC%9C%84%ED%84%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Twitter" scheme="https://jeongwookie.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch 특정 GPU 사용하기</title>
    <link href="https://jeongwookie.github.io/2020/03/24/deeplearning/1-pytorch-cuda-gpu-allocate/"/>
    <id>https://jeongwookie.github.io/2020/03/24/deeplearning/1-pytorch-cuda-gpu-allocate/</id>
    <published>2020-03-24T07:48:48.000Z</published>
    <updated>2021-11-21T11:30:16.916Z</updated>
    
    <content type="html"><![CDATA[<p>나는 많은 딥러닝 프레임워크 중 Pytorch와 MxNet을 자주 사용하는 편이다.<br>그런데, 연구실 사람들과 GPU 서버를 함께 쓰다 보니 어떤 GPU가 현재 available한지 알아야 할 필요가 있었다.</p><p>원래는 시간대를 적당히 맞춰서 사용하곤 했는데, 멀티 GPU 세팅에 대해서는 잘 모르기도 하고 colab으로는 도저히 불편해서 쓸수가 없었으므로..ㅠㅠ 관련 정보를 찾아보고 그 결과를 간단히 공유하고자 한다.</p><p><img src="https://user-images.githubusercontent.com/25416425/77401561-7d4d0680-6df0-11ea-9cfa-b3bb0591f232.jpg" width="500"></p><a id="more"></a><h2 id="GPU-서버-상태-확인하기"><a href="#GPU-서버-상태-확인하기" class="headerlink" title="GPU 서버 상태 확인하기"></a>GPU 서버 상태 확인하기</h2><p>사용하고자 하는 서버의 GPU availability 를 먼저 알아보자. 간단하게 알아볼 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi # bash OR terminal에서 명령어를 입력할 경우</span><br><span class="line">!nvidia-smi # Jupyter Notebook에서 명령어를 입력할 경우</span><br></pre></td></tr></table></figure><p>위와 같이 입력한 경우, 아래와 같은 화면이 출력된다.<br>(만약 출력이 안되는 경우, Nvidia driver에 문제가 있는 것이기 때문에 요 부분을 다시 검토해 보자)</p><p><img src="https://user-images.githubusercontent.com/25416425/77401942-27c52980-6df1-11ea-945b-a7067cb7e388.png" width="500"></p><p>내가 사용하는 서버는 TITAN Xp 가 4개 가동중인 GPU 서버이며, 현재 1,2,3번 GPU에서는 용량이 꽉 차있는 것으로 보아 누군가가 작업을 진행하고 있는 것으로 예상된다.</p><h2 id="Default-GPU-Setup-확인하기"><a href="#Default-GPU-Setup-확인하기" class="headerlink" title="Default GPU Setup 확인하기"></a>Default GPU Setup 확인하기</h2><p>어떤 GPU를 사용할지는 위의 과정을 거쳤더니 알게 되었다. 나는 GPU:0 을 사용해야 하는구만.</p><p>그러면 이제 내 작업환경으로 돌아가, 현재는 어떤 GPU를 사용하도록 셋팅 되어있는지 확인하는 과정이 필요하다.<br>마치 <code>os.getcwd()</code> 으로 현재 디렉토리를 아는 것처럼..</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 현재 Setup 되어있는 device 확인</span></span><br><span class="line">device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Available devices '</span>, torch.cuda.device_count())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Current cuda device '</span>, torch.cuda.current_device())</span><br><span class="line">print(torch.cuda.get_device_name(device))</span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면 차례대로 사용가능한 GPU 디바이스의 갯수, 현재 셋업 되어있는 GPU 넘버, 그리고 GPU 디바이스의 이름을 출력한다.</p><p><img src="https://user-images.githubusercontent.com/25416425/77402508-1c263280-6df2-11ea-9e40-77288ac2287c.png" width="500"></p><p>결과를 보니, 나는 TITAN Xp 디바이스 중 2번 GPU를 사용중임을 확인할 수 있었다. (인덱스는 0번부터 시작)</p><h2 id="GPU-Allocation-변경하기"><a href="#GPU-Allocation-변경하기" class="headerlink" title="GPU Allocation 변경하기"></a>GPU Allocation 변경하기</h2><p>나는 현재 2번 GPU를 사용중인데, 이를 0번 GPU로 바꾸어야 한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU 할당 변경하기</span></span><br><span class="line">GPU_NUM = <span class="number">0</span> <span class="comment"># 원하는 GPU 번호 입력</span></span><br><span class="line">device = torch.device(<span class="string">f'cuda:<span class="subst">&#123;GPU_NUM&#125;</span>'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">torch.cuda.set_device(device) <span class="comment"># change allocation of current GPU</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Current cuda device '</span>, torch.cuda.current_device()) <span class="comment"># check</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Additional Infos</span></span><br><span class="line"><span class="keyword">if</span> device.type == <span class="string">'cuda'</span>:</span><br><span class="line">    print(torch.cuda.get_device_name(GPU_NUM))</span><br><span class="line">    print(<span class="string">'Memory Usage:'</span>)</span><br><span class="line">    print(<span class="string">'Allocated:'</span>, round(torch.cuda.memory_allocated(GPU_NUM)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>), <span class="string">'GB'</span>)</span><br><span class="line">    print(<span class="string">'Cached:   '</span>, round(torch.cuda.memory_cached(GPU_NUM)/<span class="number">1024</span>**<span class="number">3</span>,<span class="number">1</span>), <span class="string">'GB'</span>)</span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면 0번 GPU를 사용하도록 변경하고, 해당 GPU의 cuda memory 상태를 간략하게 출력한다.</p><p><img src="https://user-images.githubusercontent.com/25416425/77403002-e2a1f700-6df2-11ea-9b8a-d3a6fd23dd10.png" width="600"></p><p>제일 위의 출력 결과물을 확인해 보니, 성공적으로 Current cuda device가 2에서 0으로 바뀌었음을 알 수 있다.</p><p>모쪼록 GPU 서버가지고 싸우지 말고(?) 딥러닝을 즐기도록 하자 :)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;나는 많은 딥러닝 프레임워크 중 Pytorch와 MxNet을 자주 사용하는 편이다.&lt;br&gt;그런데, 연구실 사람들과 GPU 서버를 함께 쓰다 보니 어떤 GPU가 현재 available한지 알아야 할 필요가 있었다.&lt;/p&gt;
&lt;p&gt;원래는 시간대를 적당히 맞춰서 사용하곤 했는데, 멀티 GPU 세팅에 대해서는 잘 모르기도 하고 colab으로는 도저히 불편해서 쓸수가 없었으므로..ㅠㅠ 관련 정보를 찾아보고 그 결과를 간단히 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/77401561-7d4d0680-6df0-11ea-9cfa-b3bb0591f232.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅳ. Deep Learning" scheme="https://jeongwookie.github.io/categories/%E2%85%A3-Deep-Learning/"/>
    
      <category term="Pytorch" scheme="https://jeongwookie.github.io/categories/%E2%85%A3-Deep-Learning/Pytorch/"/>
    
    
  </entry>
  
  <entry>
    <title>패키지 없이 트위터 데이터 수집하기 with Python</title>
    <link href="https://jeongwookie.github.io/2020/02/25/datascience/twitter/1-twitter-data-crawling-without-package/"/>
    <id>https://jeongwookie.github.io/2020/02/25/datascience/twitter/1-twitter-data-crawling-without-package/</id>
    <published>2020-02-25T09:27:19.000Z</published>
    <updated>2021-11-21T11:21:31.959Z</updated>
    
    <content type="html"><![CDATA[<p>이전에 트위터 데이터를 키워드를 기준으로 크롤링하는 글을 쓴적이 있다. 최근 내가 진행하는 연구에서도 트위터 크롤링이 계속 요구되었고, 정말 다양한 패키지와 방법을 사용해 왔다.</p><p>Tweepy나 TwitterScraper 등 좋은 패키지들이 github에 많이 공유되어 있는데, 뭔가 내 맘에 드는 게 없어서 순정으로 돌아가보기로 했다. </p><p>이번 포스트에서는 <u>일절 패키지 없이 트위터 API로만 크롤링</u>을 시도해 볼 것이다. 요즘 대단히 이슈가 되는 코로나 바이러스에 대해서 키워드를 설정하고, 관련 트윗을 수집해 보자!</p><p><img src="https://user-images.githubusercontent.com/25416425/75331914-d8a9d880-58c6-11ea-8781-1ae4dce07e5d.jpg" width="500"></p><a id="more"></a><h2 id="트위터-개발자-등록하기"><a href="#트위터-개발자-등록하기" class="headerlink" title="트위터 개발자 등록하기"></a>트위터 개발자 등록하기</h2><p>먼저, 트위터 공식 API를 사용하려면 인증키를 받아야 한다.<br>본 포스트에서는 관련 프로세스들을 다루지 않겠다. 너무 기본적인 세팅이라.. 각자 알아서 등록하도록!</p><p>간단하게 노트하면,</p><ol><li><a href="https://developer.twitter.com/" rel="external nofollow noopener noreferrer" target="_blank">트위터 개발자 홈페이지</a>에 접속해서 개발자로 신청하기</li><li>App 만들고, OAuth Key 발급 받기</li></ol><p>2번 프로세스에 대해 다른 블로그들 중 설명이 잘 되어있는 곳을 찾았다. <a href="https://ericnjennifer.github.io/python_crawling/2018/01/05/PythonCrawling_Chapt3.html" rel="external nofollow noopener noreferrer" target="_blank">Mark Lee 님의 블로그</a>를 참고해서 키를 발급 받아 옵시다..!!</p><p><img src="https://user-images.githubusercontent.com/25416425/75333305-3b9c6f00-58c9-11ea-9b7f-b65d52b57b6b.png" width="400"></p><p>위와 같이 키를 확인할 수 있다면, 준비는 끝났다.</p><h2 id="트위터-API-연결하기"><a href="#트위터-API-연결하기" class="headerlink" title="트위터 API 연결하기"></a>트위터 API 연결하기</h2><p>이제 파이참 또는 주피터를 열 시간이다.<br>본격적으로 트위터를 수집하기 전, 위에서 발급받은 인증키를 연동시켜, 제대로 연결되었는지 status를 먼저 확인해 보자.</p><p>트위터 공식 API 문서에서는 다양한 형태의 OAuth를 지원하는데, 우리는 OAuth2 를 사용하여 인증할 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 트위터 API 개발자 키를 아래에 입력</span></span><br><span class="line">client_key = <span class="string">'YOUR-CLIENT-KEY'</span></span><br><span class="line">client_secret = <span class="string">'YOUR-CLIENT-SECRET-KEY'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># b64 encoded 형태로 만드는 과정 </span></span><br><span class="line">key_secret = <span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(client_key, client_secret).encode(<span class="string">'ascii'</span>)</span><br><span class="line">b64_encoded_key = base64.b64encode(key_secret)</span><br><span class="line">b64_encoded_key = b64_encoded_key.decode(<span class="string">'ascii'</span>)</span><br></pre></td></tr></table></figure><p>위에서는 b64 형태로 인코딩 된 키를 만들었다. 이제 이를 통해서 트위터 API와 연결하는 코드를 작성한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># request에 필요한 url 만들기</span></span><br><span class="line">base_url = <span class="string">'https://api.twitter.com/'</span></span><br><span class="line">auth_url = <span class="string">'&#123;&#125;oauth2/token'</span>.format(base_url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># HEADER 구성하기</span></span><br><span class="line">auth_headers = &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Basic &#123;&#125;'</span>.format(b64_encoded_key),</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Authentication Data section 만들기</span></span><br><span class="line">auth_data = &#123;</span><br><span class="line">    <span class="string">'grant_type'</span>: <span class="string">'client_credentials'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST request를 보내서 status 확인!</span></span><br><span class="line">auth_resp = requests.post(auth_url, headers=auth_headers, data=auth_data)</span><br><span class="line">print(auth_resp.status_code)</span><br></pre></td></tr></table></figure><p>status_code 가 200이 출력되면, 정상적으로 연결된 것이다.</p><h2 id="데이터-수집하기"><a href="#데이터-수집하기" class="headerlink" title="데이터 수집하기"></a>데이터 수집하기</h2><p>위의 코드까지는 세팅이라고 할 수 있으며, 지금부터가 실제 트위터 검색에 사용될 파라미터를 정의하는 구간이다.<br>코로나 바이러스와 연관된 트윗을 수집하는 것이 목표이므로, 키워드를 <strong>“우한폐렴”</strong> 및 <strong>“코로나”</strong> 라고 정했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bearer token 정의하기</span></span><br><span class="line">access_token = auth_resp.json()[<span class="string">'access_token'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search HEADER 구성하기</span></span><br><span class="line">search_headers = &#123;</span><br><span class="line">    <span class="string">'Authorization'</span>: <span class="string">'Bearer &#123;&#125;'</span>.format(access_token)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SEARCH TWEET</span></span><br><span class="line"><span class="comment"># Maximum number of tweets returned from a single token is 18,000 </span></span><br><span class="line"></span><br><span class="line">search_params = &#123;</span><br><span class="line">    <span class="string">'q'</span>:<span class="string">'우한폐렴 OR 코로나'</span>,</span><br><span class="line">    <span class="string">'result_type'</span>: <span class="string">'recent'</span>, <span class="comment"># 'mixed' or 'popular' 로도 지정 가능</span></span><br><span class="line">    <span class="string">'count'</span>:<span class="number">10</span>, <span class="comment"># 디폴트 값은 15이며, 최대 100까지 지정 가능</span></span><br><span class="line">    <span class="string">'retryonratelimit'</span>:<span class="literal">True</span>, <span class="comment"># rate limit에 도달했을 때 자동으로 다시 trial</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search_url = <span class="string">'&#123;&#125;1.1/search/tweets.json'</span>.format(base_url)</span><br><span class="line">search_resp = requests.get(</span><br><span class="line">    search_url, headers=search_headers, </span><br><span class="line">    params=search_params</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>위 코드를 살행하면, <code>search_resp</code>에 우리가 원하는 결과값이 저장된다. 위에서는 간단하게 <strong>“최근 10개의 우한폐렴 또는 코로나 라는 단어가 포함된 트윗을 가져와!”</strong> 라고 <code>search_params</code>을 지정했지만, 더 다양한 옵션들이 존재한다. 궁금하면 <a href="https://developer.twitter.com/en/docs/tweets/search/api-reference/get-search-tweets" rel="external nofollow noopener noreferrer" target="_blank">트위터 공식 API 문서</a>를 참고하자.</p><h2 id="Rate-Limit-확인하기"><a href="#Rate-Limit-확인하기" class="headerlink" title="Rate Limit 확인하기"></a>Rate Limit 확인하기</h2><p>위에서는 간단하게 10개의 트윗만 수집했지만, 1000개 또는 그 이상의 트윗을 수집하려는 사용자도 분명 있을 것이다. (물론 나도 위 방법으로 100만개 이상을 수집해 왔으니..) 이런 경우에는 트위터에서 명시해 놓은 Rate Limit에 대해서 민감하게 코드를 작성할 필요가 있다.</p><p>방금 위 코드를 실행시켰다면, 트위터 서버에 1번 데이터를 요청한 셈이 된다. 트위터에서 얼마나 요청을 받아줄까?<br>아래의 코드는 rate limit을 확인할 수 있게 해준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rate limit URL</span></span><br><span class="line">url = <span class="string">'https://api.twitter.com/1.1/application/rate_limit_status.json'</span></span><br><span class="line">search_resp = requests.get(url, headers=search_headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 확인하기</span></span><br><span class="line">json.loads(search_resp.content)[<span class="string">'resources'</span>][<span class="string">'search'</span>]</span><br></pre></td></tr></table></figure><p>위 코드를 그대로 실행시키면, 트위터에서 제공하는 limit가 얼마이고 이 중 현재 남은 사용량이 얼마나 되는지 직관적으로 확인할 수 있다.</p><p>다만, 현재는 출력되는 limit가 450 으로 나오는데 직접 코드를 돌려보니 허용량을 초과하지 않았는데도 크롤러가 멈추는 현상이 있었다. 정확하게 확인하려면 <a href="https://developer.twitter.com/en/docs/developer-utilities/rate-limit-status/api-reference/get-application-rate_limit_status" rel="external nofollow noopener noreferrer" target="_blank">트위터 공식 API Ref</a>을 참고하자. 여기서는 <strong>15분 당 180번 요청 허용</strong> 이라고 나와 있었다.</p><p>참고로, 나는 <code>search_resp.content</code> 내의 정보를 확인하고, error가 존재하는 경우 크롤러를 강제로 15분동안 쉬도록 코드를 작성해서 사용했다.</p><h2 id="데이터-확인하기"><a href="#데이터-확인하기" class="headerlink" title="데이터 확인하기"></a>데이터 확인하기</h2><p>데이터 수집은 완료했고.. 이제 수집된 데이터를 확인해보자.<br>10개의 트윗을 예시로 수집하였고, 이를 <code>pandas</code>로 읽으면 편하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">Data = json.loads(search_resp.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dict -&gt; Dataframe</span></span><br><span class="line">df = pd.DataFrame(Data[<span class="string">'statuses'</span>])</span><br><span class="line">df[[<span class="string">"id"</span>,<span class="string">'created_at'</span>,<span class="string">'text'</span>,<span class="string">'retweet_count'</span>]] <span class="comment"># 몇 개의 칼럼만 확인해보기</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/75337214-e879ea80-58cf-11ea-91d8-aeb1a00fe3b8.png" width="700"></p><p>잘 보인다! 총 28개의 칼럼이 있는데, 이 중 관심이 있는 4개의 칼럼만 예시로 출력한 것이다. GOOD!!</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이런 식으로 패키지 없이 트위터에서 제공하는 공식 API로만 트위터를 수집할 수 있다.<br>다만, 공짜로 이용하는 것이기 때문에 기본적으로 standard API와 동일한 제약이 따른다. 무엇인고 하니, rate limit와 같은 속성도 있지만 무엇보다도 full-archive를 보장받지 못한다. 즉, 2월 20일자 트윗 중 “우한폐렴” 및 “코로나” 가 포함된 트윗을 모두 수집하라고 코드를 실행시켜도 모든 트윗을 긁어왔다고 보장해 주지 않는다.</p><p>다시 한번 한계점을 정리해 본다면,</p><ol><li>트윗을 성공적으로 크롤링 하여도, 기간 내 모든 트윗을 수집하였다고 보장하지 못한다.</li><li>Standard API의 한계 때문에, 오늘을 기준으로 7일 이전의 데이터만 크롤링이 가능하다.</li></ol><p>한계점을 극복하려면, 어쩔수 없이 다른 파이썬 패키지 또는 Premium API를 결제해야 한다.<br>그러나 미리미리 트위터를 주기적으로 크롤링 해 놓는다면, 공짜로 양질의 데이터를 손쉽게 얻을 수 있을 것이다.</p><p>아래는 트윗 10개 말고 100개를 긁어왔을 때 간단하게 frequency를 1초 별로 그려본 것이다. 예쁘게 잘 나오는군 후후</p><p><img src="https://user-images.githubusercontent.com/25416425/75339811-92f40c80-58d4-11ea-9cb2-c38f48489bf6.png" width="400"></p><p>끝!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이전에 트위터 데이터를 키워드를 기준으로 크롤링하는 글을 쓴적이 있다. 최근 내가 진행하는 연구에서도 트위터 크롤링이 계속 요구되었고, 정말 다양한 패키지와 방법을 사용해 왔다.&lt;/p&gt;
&lt;p&gt;Tweepy나 TwitterScraper 등 좋은 패키지들이 github에 많이 공유되어 있는데, 뭔가 내 맘에 드는 게 없어서 순정으로 돌아가보기로 했다. &lt;/p&gt;
&lt;p&gt;이번 포스트에서는 &lt;u&gt;일절 패키지 없이 트위터 API로만 크롤링&lt;/u&gt;을 시도해 볼 것이다. 요즘 대단히 이슈가 되는 코로나 바이러스에 대해서 키워드를 설정하고, 관련 트윗을 수집해 보자!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/75331914-d8a9d880-58c6-11ea-8781-1ae4dce07e5d.jpg&quot; width=&quot;500&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="트위터 데이터 분석하기" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%ED%8A%B8%EC%9C%84%ED%84%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D%ED%95%98%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Twitter" scheme="https://jeongwookie.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>Khaiii 형태소 분석기 사용하기</title>
    <link href="https://jeongwookie.github.io/2019/11/17/datascience/koreannlp/1-khaiii-korean-tokenizer/"/>
    <id>https://jeongwookie.github.io/2019/11/17/datascience/koreannlp/1-khaiii-korean-tokenizer/</id>
    <published>2019-11-17T09:36:23.000Z</published>
    <updated>2021-11-21T11:21:23.002Z</updated>
    
    <content type="html"><![CDATA[<p>한국어로 된 데이터를 분석할 때, 이를 적절한 형태로 토크나이즈 (tokenize)하는 과정은 반드시 필요하다.</p><p>특히나 한국어는 영어와 달리 최소 의미 전달이 단어로 이루어진 언어가 아니기 때문에 형태소 단위로 잘라주는 패키지를 자주 사용한다.</p><p>오늘은 내가 평소에 자주 사용하는 형태소 분석기 중 <strong>Khaiii 형태소 분석기</strong> 에 대해 포스팅하고자 한다.</p><p><strong>Khaiii</strong> 는 카카오에서 18년도 말에 공개한 딥러닝 기반의 형태소 분석기이다. 기존의 사전 의존 방법과는 달리 세종 코퍼스 약 1000만 어절을 학습하여 형태소 단위로 분리한다고 한다.</p><p><img src="https://user-images.githubusercontent.com/25416425/69005815-8b82a600-096a-11ea-85da-f30967fa6f26.png" width="450"></p><a id="more"></a><h2 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h2><p>설치가 생각보다 까다롭다. 오래전에 설치하여 정확한 프로세스는 잘 기억이 나지 않지만, 상당히 많은 에러 동반 끝에 설치한 기억이..</p><p>기본적으로 리눅스 환경에서만 지원한다. 윈도우에서도 할 수 있는 방법이 있는지는 잘 모르겠다.</p><p>나는 한번 설치의 어려움을 경험한 후, 다시는 리눅스 커멘드로 일일히 설치하지 않는다. 대신 도커파일을 받아서 그대로 활용한다. 도커 파일의 경우 <a href="https://github.com/kakao/khaiii/blob/master/docker/Dockerfile" rel="external nofollow noopener noreferrer" target="_blank">여기</a>를 참고하자.</p><p>위 도커파일로 Khaiii를 설치 후, 원하는 세팅을 해서 나만의 도커 이미지를 만들어 놓으면 세팅 하는데 시간을 획기적으로 줄일 수 있다. 도커 사용법의 경우 시간 날때 천천히 정리할 계획.</p><h2 id="사용하기"><a href="#사용하기" class="headerlink" title="사용하기"></a>사용하기</h2><p>설치를 완료했다면, 이제 사용해 보자. 주피터 노트북에서 아래와 같은 코드를 실행한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> khaiii <span class="keyword">import</span> KhaiiiApi</span><br><span class="line">api = KhaiiiApi(rsc_dir=<span class="string">'/deps/khaiii/build/share/khaiii'</span>) <span class="comment"># 내 설치 경로</span></span><br><span class="line"></span><br><span class="line">morphs = []</span><br><span class="line">sentence = <span class="string">"하스스톤 전장이 새로 나왔는데 재밌어요!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> api.analyze(sentence):</span><br><span class="line">    <span class="keyword">for</span> morph <span class="keyword">in</span> word.morphs:</span><br><span class="line">        morphs.append((morph.lex, morph.tag))</span><br></pre></td></tr></table></figure><p>적당한 sentence로 출력을 해보면 아래와 같이 형태소 단위로 잘 토크나이즈 된 것을 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/69006362-81b07100-0971-11ea-87cf-aae710ba18c1.png" width="350"></p><p>위 코드에서 <code>rsc_dir</code> 부분은 현재는 중요하지 않지만, 기분석 사전이나 오분석 패치 기능을 활용할 때 엄청 중요하다. 먼저 짚고 넘어가보자.</p><p>대부분이 비슷한 경로에 설치가 될 것 같은데 혹시 모르니 커멘드 창에 아래와 같은 코드를 입력한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">'khaiii*'</span> -type d</span><br></pre></td></tr></table></figure><p>khaiii 라는 이름을 가진 디렉토리를 모두 찾으라는 뜻이다. 코드를 실행하여 <code>/deps/khaiii/build/share/khaiii&#39;</code> 와 비슷하게 share 폴더 안의 khaiii의 경로를 찾으면 된다.</p><h2 id="기분석-사전-추가"><a href="#기분석-사전-추가" class="headerlink" title="기분석 사전 추가"></a>기분석 사전 추가</h2><p>기분석 사전이란 내가 원하는 단일 어절에 대해, 문맥에 상관없이 일괄적인 분석 결과를 얻고 싶을 때 추가한다.</p><p>기본적인 사용 방법은 <a href="https://github.com/kakao/khaiii/wiki/%EA%B8%B0%EB%B6%84%EC%84%9D-%EC%82%AC%EC%A0%84" rel="external nofollow noopener noreferrer" target="_blank">Khaiii 깃헙 페이지</a>에 잘 정리되어 있다.</p><p>페이지에 적힌 대로 사전 형식은 따라하면 되는데, 내가 문제를 겪은 부분은 다름 아닌 사전 빌드였다.</p><p><img src="https://user-images.githubusercontent.com/25416425/69006983-d99fa580-097a-11ea-8517-d54d5ee830af.png" width="550"></p><p>요약하자면, modulenotfounderror: no module named ‘khaiii.munjong’ 이런 에러가 뜬다.</p><p>대부분이 <code>PYTHONPATH</code> 경로 문제인데, 위와 유사한 방법으로 찾아보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">'munjong*'</span> -type d</span><br></pre></td></tr></table></figure><p>위 코드로 <code>munjong</code> 이 있는 디렉토리 위치를 찾는다. 나는 약 4개의 디렉토리 위치가 떴는데, 이중에서 적당히 파이썬 위치가 어딜까 하고 보니 보인다.</p><p><img src="https://user-images.githubusercontent.com/25416425/69007060-2768dd80-097c-11ea-881d-3a4a3dbe53e4.png" width="550"></p><p>이제 위치를 찾았으니, <code>PYTHONPATH</code> 경로를 수정한 코드를 차례대로 커멘드 창에 입력하여 사전을 빌드하면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd rsc <span class="comment"># 어디에 있던 rsc로 와서 실행하기</span></span><br><span class="line">mkdir -p ../build/share/khaiii</span><br><span class="line">PYTHONPATH=/deps/khaiii/src/main/python/ ./bin/compile_preanal.py --rsc-src=./src --rsc-dir=/deps/khaiii/build/share/khaiii</span><br></pre></td></tr></table></figure><p>빌드 완료! 혹시 빌드한 사전이 적용이 안된다면, <code>rsc_dir</code> 경로를 다시 확인하자.</p><h2 id="오분석-패치"><a href="#오분석-패치" class="headerlink" title="오분석 패치"></a>오분석 패치</h2><p>오분석 패치는 기계학습 모델의 결과로 출력된 결과가 오분석일 경우, 이를 원하는 정분석으로 바로잡을 수 있는 사용자 사전이다.</p><p>기분석 사전과 마찬가지로 기본적인 사용 방법은 <a href="https://github.com/kakao/khaiii/wiki/%EC%98%A4%EB%B6%84%EC%84%9D-%ED%8C%A8%EC%B9%98" rel="external nofollow noopener noreferrer" target="_blank">Khaiii 깃헙 페이지</a>에 잘 정리되어 있다.</p><p>정해진 포멧을 맞추어 등록하고, 이를 빌드하면 되는데 위의 오분석 패치와 마찬가지로 약간의 코드 수정이 필요하다. (PYTHONPATH 부분)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd rsc <span class="comment"># 어디에 있던 rsc로 와서 실행하기</span></span><br><span class="line">mkdir -p ../build/share/khaiii</span><br><span class="line">PYTHONPATH=/deps/khaiii/src/main/python/  ./bin/compile_errpatch.py --model-size=base --rsc-src ./src --rsc-dir=/deps/khaiii/build/share/khaiii</span><br></pre></td></tr></table></figure><p>빌드 완료!</p><h2 id="맺음말"><a href="#맺음말" class="headerlink" title="맺음말"></a>맺음말</h2><p>Khaiii 형태소 분석기를 사용해보면 딥러닝 기반인데 사전 기반처럼 정확하게 작동함을 확인할 수 있다.</p><p>그러나, 아쉬운 점은 띄어쓰기가 잘 안된 비문들을 넣으면 기존에 잘 사용하는 <code>Mecab</code> 형태소 분석기보다 성능이 조금 떨어진다.</p><p>그리고 내가 다루는 데이터 안에 ‘후쿠시마’ 라는 단어가 있는데, 이를 <code>Mecab</code>을 사용했을 땐 몰랐는데 자꾸 후 + 쿠시마 또는 후쿠시 + 마 로 오분석이 되더라.. 기분석 사전에 추가하는 번거로움이 있었다.</p><p>서로 장단점이 있으니 적절하게 사용하면 될 것 같다.</p><p>기분석 사전 및 오분석 패치 사전 작성 시에 기본 한글 형태소 품사표를 알고 싶다면 <a href="http://kkma.snu.ac.kr/documents/?doc=postag" rel="external nofollow noopener noreferrer" target="_blank">한글 형태소 품사 (POS) 태그표</a>를 참고하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;한국어로 된 데이터를 분석할 때, 이를 적절한 형태로 토크나이즈 (tokenize)하는 과정은 반드시 필요하다.&lt;/p&gt;
&lt;p&gt;특히나 한국어는 영어와 달리 최소 의미 전달이 단어로 이루어진 언어가 아니기 때문에 형태소 단위로 잘라주는 패키지를 자주 사용한다.&lt;/p&gt;
&lt;p&gt;오늘은 내가 평소에 자주 사용하는 형태소 분석기 중 &lt;strong&gt;Khaiii 형태소 분석기&lt;/strong&gt; 에 대해 포스팅하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Khaiii&lt;/strong&gt; 는 카카오에서 18년도 말에 공개한 딥러닝 기반의 형태소 분석기이다. 기존의 사전 의존 방법과는 달리 세종 코퍼스 약 1000만 어절을 학습하여 형태소 단위로 분리한다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/69005815-8b82a600-096a-11ea-85da-f30967fa6f26.png&quot; width=&quot;450&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="한국어 형태소 분석기" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%ED%95%9C%EA%B5%AD%EC%96%B4-%ED%98%95%ED%83%9C%EC%86%8C-%EB%B6%84%EC%84%9D%EA%B8%B0/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Korean NLP" scheme="https://jeongwookie.github.io/tags/Korean-NLP/"/>
    
  </entry>
  
  <entry>
    <title>2019년 여름, 연구실에서 근황</title>
    <link href="https://jeongwookie.github.io/2019/07/23/others/diary/10-my-summer-these-days/"/>
    <id>https://jeongwookie.github.io/2019/07/23/others/diary/10-my-summer-these-days/</id>
    <published>2019-07-23T12:53:57.000Z</published>
    <updated>2021-12-13T05:07:44.335Z</updated>
    
    <content type="html"><![CDATA[<p>쓰고 싶은 주제들은 많은데.. 요즘 블로그를 거의 못하고 있다 ㅠㅠ</p><p>덥기도 하고, 연구실에서 해야할 일도 많고 행사도 있고 정신이 없는듯.</p><p>매일 운동도 빠짐없이 하고 싶은데 밥을 제때 못먹어서 힘이 없어서 못하기도 하고, 미팅이 길어져서 타이밍을 놓치기도 하고..</p><p>그래도 간간히 블로그 들러주셔서 메일 주시는 분들이 몇 계시다는 데에 만족중 ㅋㅋ</p><p>현재 두 가지의 프로젝트에 involve 하는 중인데, 열심히는 하고 있지만 아직 갈길이 멀었다.</p><ol><li><p>네이버 뉴스 및 댓글 데이터를 바탕으로 정치적 편향성을 가진 사용자의 반응 연구</p></li><li><p>원자력 발전소와 관련한 트윗을 크롤링하여 루머의 확산에 관한 연구</p></li></ol><p>방학 때 좀 빡세게 해서 결과가 좀 나오면.. 탑 티어 컨퍼런스인 CHI나 ICWSM에 도전해 보고 싶다!! </p><p>이외에도, 최근 한 일중에 미래에 도움될 만한 일이 있다면.. <strong>도커 (Docker)</strong> 세팅을 해본 것?</p><p>처음 만져보니까 버벅대긴 했는데.. 어찌어찌 해서 나의 전용 도커파일도 만들고 내가 원하는 자연어 처리 세팅을 완료했다.</p><p>또 막상 끝내고 나니까 가르쳐주는 건 쉽더라. 시간 될 때 리마인드 겸 도커 세팅과 관련된 포스트를 작성할 계획이다.</p><p>친구들한테 물어보니, 기업에서 도커 다루는 것은 거의 필수라고 하더라고 ㅋㅋㅋ 공부한 셈 치고 머리 박은 시간들은 넘어가는 걸로. 다음엔 안헤메겠지뭐!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;쓰고 싶은 주제들은 많은데.. 요즘 블로그를 거의 못하고 있다 ㅠㅠ&lt;/p&gt;
&lt;p&gt;덥기도 하고, 연구실에서 해야할 일도 많고 행사도 있고 정신이 없는듯.&lt;/p&gt;
&lt;p&gt;매일 운동도 빠짐없이 하고 싶은데 밥을 제때 못먹어서 힘이 없어서 못하기도 하고,
      
    
    </summary>
    
      <category term="Ⅹ. Others" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/"/>
    
      <category term="일기" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/%EC%9D%BC%EA%B8%B0/"/>
    
    
      <category term="Daily life" scheme="https://jeongwookie.github.io/tags/Daily-life/"/>
    
  </entry>
  
  <entry>
    <title>Data Crawling - 크롤러 속도를 높이는 멀티프로세싱 (multiprocessing)</title>
    <link href="https://jeongwookie.github.io/2019/06/29/datascience/datacrawling/5-multiprocessing-crawler/"/>
    <id>https://jeongwookie.github.io/2019/06/29/datascience/datacrawling/5-multiprocessing-crawler/</id>
    <published>2019-06-29T09:01:17.000Z</published>
    <updated>2021-11-21T11:21:14.928Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 크롤러의 속도를 높이는 방법 중 하나를 알아보자.</p><p>우리가 10000개의 유저 데이터를 수집한다고 가정하면, 지금까지는 처음부터 차례대로 하나씩 수집한 것이다.</p><p>그런데 만약 동일한 기능을 하는 프로그램 창을 여러개 띄우고, 2500개씩 나누어 4개의 창으로 동시에 데이터를 수집하면 어떨까?</p><p>이런 것을 가능하게 하는 것이 바로 파이썬의 기본 모듈 중 하나인 멀티프로세싱 (multiprocessing)이다.</p><p><img src="https://user-images.githubusercontent.com/25416425/60382111-6237ab00-9a99-11e9-8500-c76666317467.png" width="450"></p><a id="more"></a><p>지금부터, 트위터에서 유저 데이터 (username, joined date, total tweets, followings, followers)를 멀티프로세싱을 통해 속도를 개선한 크롤러로 수집해 보겠다.</p><p>수집할 트윗은 요즘 결승 라운드를 시작하여 매우 핫한 “슈퍼밴드” 를 포함한 트윗으로, 6월 21일부터 6월 28일까지의 기간으로 정했다.</p><p>편의를 위해 트윗을 수집할 때 직접 수집하지 않고 앞서 사용하였던 <strong>GetOldTweet3</strong> 을 임포트 하였다. 자세한 내용은 <a href="https://jeongwookie.github.io/2019/06/10/190610-twitter-data-crawling/">여기</a>를 참고하자.</p><h2 id="트윗-수집하기"><a href="#트윗-수집하기" class="headerlink" title="트윗 수집하기"></a>트윗 수집하기</h2><p>먼저, <strong>GetOldTweet3</strong> 을 사용하여 특정 검색어를 포함한 트윗을 먼저 수집하고, 이런 트윗을 작성한 유저들의 닉네임 (username)을 리스트로 반환해 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import packages</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> GetOldTweets3 <span class="keyword">as</span> got</span><br><span class="line"></span><br><span class="line"><span class="comment"># 트윗 수집하는 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tweets</span><span class="params">(start_date, end_date, keyword)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 범위 끝을 포함하게 만듬</span></span><br><span class="line">    end_date = (datetime.datetime.strptime(end_date, <span class="string">"%Y-%m-%d"</span>) </span><br><span class="line">                + datetime.timedelta(days=<span class="number">1</span>)).strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 트윗 수집 기준 설정</span></span><br><span class="line">    tweetCriteria = got.manager.TweetCriteria().setQuerySearch(<span class="string">'&#123;&#125;'</span>.format(keyword))\</span><br><span class="line">                                            .setSince(start_date)\</span><br><span class="line">                                            .setUntil(end_date)\</span><br><span class="line">                                            .setMaxTweets(<span class="number">-1</span>) <span class="comment"># 모두 수집</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"==&gt; Collecting data start.."</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    tweets = got.manager.TweetManager.getTweets(tweetCriteria)</span><br><span class="line">    print(<span class="string">"==&gt; Collecting data end.. &#123;0:0.2f&#125; minutes"</span>.format((time.time() - start_time)/<span class="number">60</span>))</span><br><span class="line">    print(<span class="string">"=== Total number of tweets is &#123;&#125; ==="</span>.format(len(tweets)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tweets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 리스트 반환하는 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_users</span><span class="params">(tweets)</span>:</span></span><br><span class="line">    </span><br><span class="line">    user_list = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> tweets:</span><br><span class="line">        username = index.username</span><br><span class="line">        user_list.append(username)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> user_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 리스트 수집하기</span></span><br><span class="line">tweets = get_tweets(<span class="string">"2019-06-21"</span>, <span class="string">"2019-06-28"</span>, <span class="string">"슈퍼밴드"</span>)</span><br><span class="line">users = get_users(tweets)</span><br><span class="line"></span><br><span class="line">&gt; ==&gt; Collecting data start..</span><br><span class="line">&gt; ==&gt; Collecting data end.. 4.45 minutes</span><br><span class="line">&gt; === Total number of tweets <span class="keyword">is</span> <span class="number">3456</span> ===</span><br></pre></td></tr></table></figure><p><code>get_tweets()</code>으로 2019년 06월 21일부터 2019년 06년 28일까지 키워드 “슈퍼밴드” 를 포함한 트윗을 먼저 수집하고, <code>get_users()</code>으로 트윗을 작성한 유저의 닉네임을 리스트로 만들어 <code>users</code>에 저장하였다.</p><p>총 5분 가량 소요되었고, 조건을 만족하는 트윗은 3456개임을 확인하였다.</p><h2 id="logger-정의하기"><a href="#logger-정의하기" class="headerlink" title="logger 정의하기"></a>logger 정의하기</h2><p>본격적으로 멀티프로세싱에 들어가기 전, 효과적으로 결과를 볼 수 있도록 도와주는 로깅 (logging)을 먼저 소개하고자 한다.</p><p>로깅 (logging)이란 현재 우리의 프로그램이 어떤 상태를 가지고 있는지 외부 출력을 하게 만들어서, 개발자들이 프로그램의 상황을 직접 눈으로 확인할 수 있도록 하는 것이다.</p><p>얼핏 보면 우리가 지금까지 사용한 <code>print()</code>와 유사하지만, 다양한 옵션의 출력을 미리 세팅해 둘 수 있어서 훨씬 유연하게 상황에 따라 대처할 수 있다.</p><p>코드부터 살펴보자. 파이썬 기본 모듈이므로 따로 설치할 필요는 없다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line"><span class="comment"># logging 설정</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_logger</span><span class="params">()</span>:</span></span><br><span class="line">    logger = logging.getLogger(<span class="string">"my"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> len(logger.handlers) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> logger</span><br><span class="line">    </span><br><span class="line">    logger.setLevel(logging.INFO)</span><br><span class="line">    stream_hander = logging.StreamHandler()</span><br><span class="line">    logger.addHandler(stream_hander)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> logger</span><br></pre></td></tr></table></figure><p><em>my</em> 라는 로거 (logger)를 정의하고, <code>INFO</code> 이상의 등급에 해상하는 로그만 출력하도록 <code>setLevel()</code>을 통해 설정하였다. 또한 프로그램 실행과 동시에 결과를 보여줄 수 있도록 핸들러를 정의하고, 이를 콘솔창에 출력하도록 하였다.</p><p>또한, 로그가 중복되어 두번씩 출력되는 현상을 방지하기 위해 <code>logging.handlers</code>를 이미 불러온 경우에는 또 불러오지 않도록 중간에 if문을 넣었다.</p><p>대단히 간단한 옵션들만 사용한 것인데, 자세한 내용은 <a href="https://hamait.tistory.com/880" rel="external nofollow noopener noreferrer" target="_blank">이승현님의 블로그</a>를 참고하자. 여러가지 옵션에 대해서 상세히 다루어 놓았다.</p><h2 id="유저-데이터-수집하기"><a href="#유저-데이터-수집하기" class="headerlink" title="유저 데이터 수집하기"></a>유저 데이터 수집하기</h2><p>아까 수집해 놓은 유저 닉네임 (username)을 바탕으로, 유저 데이터를 수집해 보자.</p><p>수집에 사용할 툴은 <code>bs4</code> 패키지의 <code>BeautlfulSoup</code>이며, <em>lxml</em> 형식으로 데이터를 받아올 것이다. </p><p>수집할 유저 데이터는 유저 닉네임, 가입일, 전체 작성 트윗수, 팔로워수, 팔로잉수 이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crawl_userdata</span><span class="params">(username)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># setting</span></span><br><span class="line">    url = <span class="string">'https://twitter.com/&#123;&#125;'</span>.format(username)</span><br><span class="line">    mylogger.info(<span class="string">"&#123;&#125; 유저의 데이터 수집 시작"</span>.format(username))</span><br><span class="line">    HEADER = &#123;<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36'</span>&#125;</span><br><span class="line">    response = requests.get(url, headers=HEADER)</span><br><span class="line">    html = response.text</span><br><span class="line"></span><br><span class="line">    <span class="comment"># parsing</span></span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">"lxml"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># parsing fail</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user_profile_header = soup.find(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>:<span class="string">'ProfileHeaderCard'</span>&#125;)</span><br><span class="line">        user_profile_canopy = soup.find(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>:<span class="string">'ProfileCanopy-nav'</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># data collect</span></span><br><span class="line">        user = user_profile_header.find(<span class="string">'a'</span>, &#123;<span class="string">'class'</span>:<span class="string">'ProfileHeaderCard-nameLink u-textInheritColor js-nav'</span>&#125;)[<span class="string">'href'</span>].strip(<span class="string">"/"</span>) </span><br><span class="line"></span><br><span class="line">        date_joined = user_profile_header.find(<span class="string">'div'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileHeaderCard-joinDate"</span>&#125;).find(<span class="string">'span'</span>, &#123;<span class="string">'class'</span>:<span class="string">'ProfileHeaderCard-joinDateText js-tooltip u-dir'</span>&#125;)[<span class="string">'title'</span>]</span><br><span class="line">        date_joined = date_joined.split(<span class="string">"-"</span>)[<span class="number">1</span>].strip()</span><br><span class="line">        <span class="keyword">if</span> date_joined <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            data_joined = <span class="string">"Unknown"</span></span><br><span class="line"></span><br><span class="line">        tweets = user_profile_canopy.find(<span class="string">'span'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileNav-value"</span>&#125;)[<span class="string">'data-count'</span>]</span><br><span class="line">        <span class="keyword">if</span> tweets <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            tweets = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        mylogger.info(<span class="string">"&#123;&#125; 유저의 데이터 수집 중 알수없는 오류가 발생했습니다."</span>.format(username))</span><br><span class="line">        mylogger.info(<span class="string">"링크 : &#123;&#125;"</span>.format(url))</span><br><span class="line">        user, date_joined, tweets, following, followers = username, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 블락 계정 특징 : 팔로워, 팔로잉 수가 안보임</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        test_following = user_profile_canopy.find(<span class="string">'li'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileNav-item ProfileNav-item--following"</span>&#125;)</span><br><span class="line">        test_followers = user_profile_canopy.find(<span class="string">'li'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileNav-item ProfileNav-item--followers"</span>&#125;)</span><br><span class="line"></span><br><span class="line">        following = test_following.find(<span class="string">'span'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileNav-value"</span>&#125;)[<span class="string">'data-count'</span>]</span><br><span class="line">        followers = test_followers.find(<span class="string">'span'</span>, &#123;<span class="string">'class'</span>:<span class="string">"ProfileNav-value"</span>&#125;)[<span class="string">'data-count'</span>]</span><br><span class="line"></span><br><span class="line">        mylogger.info(<span class="string">"&#123;&#125; 유저의 데이터 수집 완료"</span>.format(username))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        mylogger.info(<span class="string">"&#123;&#125; 유저는 블락된 계정입니다."</span>.format(username))</span><br><span class="line">        following = <span class="string">"Block"</span></span><br><span class="line">        followers = <span class="string">"Block"</span></span><br><span class="line"></span><br><span class="line">    result = [user, date_joined, tweets, following, followers]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>트위터 데이터를 어려번 수집하여 보니 안 사실인데, 트위터의 정책상 블락 (block)된 유저들은 가입일이나 전체 작성한 트윗 수 등은 조회가 가능하지만, 팔로잉 수나 팔로워 수는 보이지 않는다. 처음에는 이런 정보를 유저가 선택적으로 오픈할 수 있는 옵션이 있는지 의심했지만, 그런 옵션은 공식적으로 제공하지 않았다.</p><p>중간중간에 <code>try-except</code>문을 사용하여 위와 같은 경우를 방지하였다. <code>BeautifulSoup</code>을 통해 원하는 데이터를 수집하는 부분은 따로 설명하지 않았다. 좀 더 알고 싶다면 <a href="https://jeongwookie.github.io/2019/03/18/190318-naver-finance-data-crawling-using-python/">과거에 작성한 글</a>이 있으니 참고.</p><h2 id="멀티프로세싱-사용하기"><a href="#멀티프로세싱-사용하기" class="headerlink" title="멀티프로세싱 사용하기"></a>멀티프로세싱 사용하기</h2><p>모든 준비가 끝났다. 이제 실제 코드를 멀티프로세싱을 통해서 병렬화 하여 돌리면 된다. (병렬 크롤링)</p><p>유의할 점은, 멀티프로세싱을 사용할 때, <code>main()</code>이 무엇인지 정확히 언급해 주어야 오류를 방지할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 유저 정보 Multiprocessing</span></span><br><span class="line"><span class="keyword">global</span> user_info</span><br><span class="line">user_info = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    user_list = users</span><br><span class="line">    pool_size = len(user_list)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pool_size &lt; <span class="number">8</span>:</span><br><span class="line">        pool = Pool(pool_size)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pool = Pool(<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> pool.map(crawl_userdata, user_list):</span><br><span class="line">        user_info.append(user)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    </span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    mylogger = get_logger()</span><br><span class="line">    mylogger.info(<span class="string">"유저 정보 수집 시작"</span>)</span><br><span class="line">    </span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">    end_time = (time.time() - start_time)/<span class="number">60</span></span><br><span class="line">    mylogger.info(<span class="string">"유저 정보 수집 종료.. &#123;0:0.2f&#125; 분 소요"</span>.format(end_time))</span><br><span class="line">    mylogger.info(<span class="string">"총 수집된 유저 정보는 &#123;&#125; 개 입니다."</span>.format(len(user_info)))</span><br></pre></td></tr></table></figure><p><code>Pool</code>은, 몇개의 창을 열어서 동시에 프로그램을 돌릴지 정의하는 함수이다. 위 코드에서는 우리가 수집할 데이터의 갯수가 8 이하일 경우에는 그 숫지만큼, 아닐 경우 8개를 동시에 실행해서 수집하도록 셋팅하였다.</p><p>이어서 <code>pool.map()</code>으로 적용하고 싶은 함수 <code>crawl_userdata()</code>와 그 적용 대상이 되는 <code>user_list</code>을 차례로 적고 for문을 완성한다.</p><p>위 코드를 실행시켜보면, 총 3456개의 유저 정보가 <u>단 10분만에 크롤링 됨</u>을 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/60386591-e1e16c00-9ad1-11e9-8c41-fca71061bddb.png" width="700"></p><p>결과가 어떤 형태로 나오는지 보여주기 위해, 해당 트윗도 추가해서 위와 같이 출력해 보았다.</p><p>위의 정보 뿐만 아니라 트윗의 업로드 시각, 리트윗 수, 관심글 수, 지역 등의 데이터를 추가로 수집 가능하다.</p><p>이전 다루었던 트위터 데이터 크롤링의 코드로 실행하면 거의 3시간씩 걸린 작업을 멀티 프로세싱을 통해 대단히 빠른 속도로 시간을 단축시켜 보았다.</p><p>하지만, 이는 공격적인 크롤링으로 오인받아 일부 사이트의 경우 차단당할 우려가 있으므로.. 상황에 맞게 조심스레(?) 사용하자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;이번에는 크롤러의 속도를 높이는 방법 중 하나를 알아보자.&lt;/p&gt;
&lt;p&gt;우리가 10000개의 유저 데이터를 수집한다고 가정하면, 지금까지는 처음부터 차례대로 하나씩 수집한 것이다.&lt;/p&gt;
&lt;p&gt;그런데 만약 동일한 기능을 하는 프로그램 창을 여러개 띄우고, 2500개씩 나누어 4개의 창으로 동시에 데이터를 수집하면 어떨까?&lt;/p&gt;
&lt;p&gt;이런 것을 가능하게 하는 것이 바로 파이썬의 기본 모듈 중 하나인 멀티프로세싱 (multiprocessing)이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/60382111-6237ab00-9a99-11e9-8500-c76666317467.png&quot; width=&quot;450&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="데이터 크롤링" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Twitter" scheme="https://jeongwookie.github.io/tags/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>19년 카이스트 봄학기 후기</title>
    <link href="https://jeongwookie.github.io/2019/06/28/others/diary/9-spring-semester-finish/"/>
    <id>https://jeongwookie.github.io/2019/06/28/others/diary/9-spring-semester-finish/</id>
    <published>2019-06-28T07:03:25.000Z</published>
    <updated>2021-12-13T05:07:36.666Z</updated>
    
    <content type="html"><![CDATA[<p>카이스트에서의 도전적인(?) 한 학기가 드디어 끝났다.</p><p>정말 많은 일들을 한꺼번에 진행하느라 힘들었지만, 그만큼 의미있었던 한 학기였다.</p><p>나의 무기를 가지고 싶어 시작했던 일들이었던 만큼, 재미있고 가슴뛰는 무언가를 찾아서 움직였던 과거와는 달리 모든 일에 조금 진지하게 임하였던 것 같다.</p><a id="more"></a><p>나는 데이터 가반의 의사 결정 방법이 스타트업의 서비스 설계에 있어 대단히 중요하다고 생각한다.</p><p>단순히 데이터를 쌓아놓고, 그 후에 어떻게 이 데이터를 읽어낼 것인가를 이야기 하는 것이 아니라, 첫 단계부터 어떤 유저들에게 어떤 데이터를 수집할 것인지, 그것을 어떻게 처리하여 다시 우리의 유저에게 어떤 영향을 미칠 것인지 그 시스템 자체를 설계하기를 원했다.</p><p>지금까지 해왔던 것 처럼, 경영 분야의 지식을 익히고 또 다른 창업 팀에서 활동하는 선택지도 분명 있었다.</p><p>하지만, 스스로 해보고 싶어졌다. 창업을 경험하면서 조금만 진전이 없으면 따라오던 답없는 질문.. 내가 정말 잘하는 것이 무엇인가? 나는 정말 대체가능한 인원이 아닌건가? 우리 회사의 성장에 꼭 필요한 인재일까? 하는 의문들…</p><p>나 스스로에게 무기를 쥐어주고 싶었다. 창업이 원래 답없고 실패 확률이 매우 높은 일 아닌가. 뭐라도 믿는 구석이 있어야 뚝심있게 밀고 나갈 수 있는 것 같다. 스스로에게 자신감이 떨어지면 이도저도 어렵지 않을까. </p><p>그래서 다시 코딩을 시작했다. 학부때 기본 과정은 들었고, 수학에 자신이 있었기 때문에 어떻게든 할 수 있지 않을까 생각했다.</p><p>기회가 되어 기초과학연구원의 데이터 사이언스 연구실에서 일할 수 있게 되었고, 데이터를 직접 수집하기 시작했다. </p><p>동시에 카이스트 전산학부 및 산업공학과의 빅데이터, 알고리즘, 머신러닝 및 딥러닝 관련 전공 수업들을 전부 수강했다.</p><p>솔직히 엄청 힘들었다.. 사실 전공 수업만 따라가기도 벅찬데 연구실에서 맡은 프로젝트도 있었고, 창업석사의 메인 트랙인 창업 수업이 기본적으로 조별과제라서 그냥 개인 시간이 거의 없었던 것 같다.</p><p>그래도 끝내고 나니 확실히 기본적인 개념들은 전부 익힌 것 같고, 최신 논문을 읽어도 무슨 말인지 따라갈 수 있게 되었다!</p><p>그리고.. 힘든 것과는 별개로, 더 해보고 싶어졌다. 내가 수집한 데이터에 새로운 모델을 적용해 보고 싶고, 전처리를 더 잘하고 싶고, 수집도 더 우아하게 (?) 해보고 싶고 막 하고 싶은 것들이 쑥쑥 늘어났다. 욕심이 생긴다고 해야할까?</p><p>이번 방학은 연구실에 오롯히 매진할 생각이다. 현재 맡은 프로젝트는 네이버 뉴스 데이터를 기반으로 한 의견성 기사 분류 및 분석, 특정 키워드를 포함한 트위터 데이터 수집 및 분석 등이다. </p><p>프로젝트의 주제들을 보면 한국어 NLP인데, 이번에 구글브레인에서 발표한 XLNet을 적용해보고 싶고.. 이때까지는 형태소 분석기를 Mecab을 사용했는데 딥러닝 기반의 Khaiii를 사용해서 여러 모델들을 적용해 볼 생각이다.</p><p>이와 별개로 연구실에서 Twitch 채팅 로그를 기반으로 Hatespeech 분석, 비언어적 특성 (이모티콘 등) 분석 등을 진행하고 계신 분들이 있는데, 여력이 된다면 조인하고 싶다.</p><blockquote><p>2019년 한국정보과학회 참여 사진</p></blockquote><p><img src="https://user-images.githubusercontent.com/25416425/60381891-34049c00-9a96-11e9-8103-00d00ea2743e.jpeg" width="500"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;카이스트에서의 도전적인(?) 한 학기가 드디어 끝났다.&lt;/p&gt;
&lt;p&gt;정말 많은 일들을 한꺼번에 진행하느라 힘들었지만, 그만큼 의미있었던 한 학기였다.&lt;/p&gt;
&lt;p&gt;나의 무기를 가지고 싶어 시작했던 일들이었던 만큼, 재미있고 가슴뛰는 무언가를 찾아서 움직였던 과거와는 달리 모든 일에 조금 진지하게 임하였던 것 같다.&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅹ. Others" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/"/>
    
      <category term="일기" scheme="https://jeongwookie.github.io/categories/%E2%85%A9-Others/%EC%9D%BC%EA%B8%B0/"/>
    
    
      <category term="Daily life" scheme="https://jeongwookie.github.io/tags/Daily-life/"/>
    
  </entry>
  
  <entry>
    <title>Data Crawling - 파이썬을 이용한 트위터 수집하기</title>
    <link href="https://jeongwookie.github.io/2019/06/10/datascience/datacrawling/4-twitter-data-crawling/"/>
    <id>https://jeongwookie.github.io/2019/06/10/datascience/datacrawling/4-twitter-data-crawling/</id>
    <published>2019-06-10T09:24:31.000Z</published>
    <updated>2021-11-21T11:21:07.615Z</updated>
    
    <content type="html"><![CDATA[<p>어떤 사건에 대한 사람들의 즉각적인 관심과 반응, 그리고 영향력자들이 어떻게 일반 사용자에게 영향을 미치는지 분석하는 데는 트위터 만한 SNS가 없다.</p><p>본 포스트에서는 예제로 19년 4월 4주차에서 <u>어벤져스</u> 또는 <u>스포</u>가 포함된 트윗을 수집해 볼 것이다.</p><p>어벤져스 엔드게임은 19년 4월 24일에 개봉해서 엄청난 인기를 끌었는데, 한동안 SNS에서 일명 스포 (스포일러)를 한다고 절대 아무거나 클릭하지 말라고 소동이 있었던 것으로 기억한다.</p><p>개봉일 전후로 트윗 수가 차이가 나고, <u>스포</u>와 같이 작성된 트윗이 많을 것으로 기대된다. </p><p><img src="https://user-images.githubusercontent.com/25416425/59194117-ebf30780-8bc2-11e9-91f1-ab6b84883cd6.png" width="400"></p><a id="more"></a><h2 id="수집-도구-선택"><a href="#수집-도구-선택" class="headerlink" title="수집 도구 선택"></a>수집 도구 선택</h2><p>트위터에서는 공식적으로 데이터 수집을 지원하는 API를 제공하고 있는데, 이름은 <strong>Tweepy</strong>. 최근 자료들을 얻는 데 있어서는 간단하고 빠르다.</p><p>그러나, 이 방법에는 치명적인 단점이 존재하는데.. 바로 현재 시간부터 7일 이전까지의 데이터만 수집이 가능하다는 점이다.</p><p>그 이전의 데이터를 수집하고 싶다면, Premium-Api를 구매해야 한다.. <a href="https://developer.twitter.com/en/premium-apis" rel="external nofollow noopener noreferrer" target="_blank">트위터 개발자 홈페이지</a>에 접속하면 아래와 같은 가격 플랜을 안내하고 있다.</p><p><em>Pricing for the elevated tiers of the Search Tweets: 30-day endpoint start at <strong>$149/month</strong> for 500 requests, while pricing for the Search Tweets: Full-archive endpoint starts at <strong>$99/month</strong> for 100 requests.</em>   </p><p>상당한 비용이 발생함을 알 수 있다. 그럼 다른 방법은 없을까?</p><p>직접 크롤러를 만들수도 있지만 그건 최후의 (?) 수단이고, 누군가 만들어 놓은 도구가 있다면 쓰는 것이 인지상정! 다행히 오래된 트윗을 수집할 수 있는 <a href="https://github.com/Mottl/GetOldTweets3" rel="external nofollow noopener noreferrer" target="_blank"><strong>GetOldTweet3</strong></a> 이라는 패키지가 있다.</p><p><img src="https://user-images.githubusercontent.com/25416425/59187501-901f8300-8bb0-11e9-954d-ca8994b0c726.png" width="700"></p><p>이 패키지를 사용해서 수집할 수 있는 변수들을 확인해 보니, 내가 원하는 것은 대부분 수집이 가능했다.</p><ul><li>업로드 유저 아이디 (username)</li><li>트윗 링크 (permalink)</li><li>트윗 내용 (text)</li><li>업로드 시간 (date)</li><li>리트윗 수 (retweets)</li><li>관심글 수 (favorites)</li></ul><p>또한, 다양한 기준으로 데이터 수집 범위를 설정할 수 있었다.</p><ul><li>특정 유저 아이디로 트윗 검색 (setUsername)</li><li>기간 안의 트윗 검색 (setSince / setUntil)</li><li>특정 검색어가 포함된 트윗 검색 (setQuerySearch)</li><li>기준 위치를 설정하고 근처에서 생성된 트윗 검색 (setNear / setWithin)</li><li>출력할 최대 트윗 수 지정 (setMaxTweets)</li></ul><p>좀 더 자세한 옵션 및 사용 방법은 <a href="https://github.com/Mottl/GetOldTweets3" rel="external nofollow noopener noreferrer" target="_blank">GetOldTweet3 github</a> 을 참고하자.</p><h2 id="패키지-준비"><a href="#패키지-준비" class="headerlink" title="패키지 준비"></a>패키지 준비</h2><p>본격적으로 크롤링에 앞서, 먼저 <strong>GetOldTweet3</strong> 패키지를 설치한다. 본 포스트에서는 python 3.7, ubuntu 18.04 의 개발 환경을 기본으로 한다. Jupyter Notebook으로 코드를 작성하였다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GetOldTweet3 사용 준비</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> GetOldTweets3 <span class="keyword">as</span> got</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    !pip install GetOldTweets3</span><br><span class="line">    <span class="keyword">import</span> GetOldTweets3 <span class="keyword">as</span> got</span><br></pre></td></tr></table></figure><p>또한, 추가적인 데이터 수집을 위해서 이전 포스트에서도 사용하였던 <strong>Beautifulsoup4</strong> 가 설치되어 있는지 확인한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># BeautifulSoup4 사용 준비</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    !pip install bs4</span><br><span class="line">    <span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br></pre></td></tr></table></figure><h2 id="수집-기간-정의하기"><a href="#수집-기간-정의하기" class="headerlink" title="수집 기간 정의하기"></a>수집 기간 정의하기</h2><p>본격적으로 크롤러를 만들어 보자. 먼저 <code>datetime</code>을 사용하여 원하는 수집 기간을 정의한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 가져올 범위를 정의</span></span><br><span class="line"><span class="comment"># 예제 : 2019-04-21 ~ 2019-04-24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">days_range = []</span><br><span class="line"></span><br><span class="line">start = datetime.datetime.strptime(<span class="string">"2019-04-21"</span>, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">end = datetime.datetime.strptime(<span class="string">"2019-04-25"</span>, <span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">date_generated = [start + datetime.timedelta(days=x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, (end-start).days)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> date <span class="keyword">in</span> date_generated:</span><br><span class="line">    days_range.append(date.strftime(<span class="string">"%Y-%m-%d"</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"=== 설정된 트윗 수집 기간은 &#123;&#125; 에서 &#123;&#125; 까지 입니다 ==="</span>.format(days_range[<span class="number">0</span>], days_range[<span class="number">-1</span>]))</span><br><span class="line">print(<span class="string">"=== 총 &#123;&#125;일 간의 데이터 수집 ==="</span>.format(len(days_range)))</span><br><span class="line"></span><br><span class="line">&gt; === 설정된 트윗 수집 기간은 <span class="number">2019</span><span class="number">-04</span><span class="number">-21</span> 에서 <span class="number">2019</span><span class="number">-04</span><span class="number">-24</span> 까지 입니다 ===</span><br><span class="line">&gt; === 총 <span class="number">4</span>일 간의 데이터 수집 ===</span><br></pre></td></tr></table></figure><p><code>days_range</code> 라는 이름의 리스트에 날짜를 %Y-%m-%d 형태로 저장해 놓았다.</p><h2 id="트윗-수집하기"><a href="#트윗-수집하기" class="headerlink" title="트윗 수집하기"></a>트윗 수집하기</h2><p>이제 본격적으로 트위터에서 데이터를 크롤링할 차례이다.</p><p><strong>GetOldTweet3</strong>는 <code>tweetCriteria</code>로 수집 기준을 정의할 수 있다.</p><p>앞에서 설정한 수집 기간에서 <u>어벤져스</u> 또는 <u>스포</u> 가 포함된 트윗을 모두 수집해 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 특정 검색어가 포함된 트윗 검색하기 (quary search)</span></span><br><span class="line"><span class="comment"># 검색어 : 어벤져스, 스포</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 수집 기간 맞추기</span></span><br><span class="line">start_date = days_range[<span class="number">0</span>]</span><br><span class="line">end_date = (datetime.datetime.strptime(days_range[<span class="number">-1</span>], <span class="string">"%Y-%m-%d"</span>) </span><br><span class="line">            + datetime.timedelta(days=<span class="number">1</span>)).strftime(<span class="string">"%Y-%m-%d"</span>) <span class="comment"># setUntil이 끝을 포함하지 않으므로, day + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 트윗 수집 기준 정의</span></span><br><span class="line">tweetCriteria = got.manager.TweetCriteria().setQuerySearch(<span class="string">'어벤져스 OR 스포'</span>)\</span><br><span class="line">                                           .setSince(start_date)\</span><br><span class="line">                                           .setUntil(end_date)\</span><br><span class="line">                                           .setMaxTweets(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 수집 with GetOldTweet3</span></span><br><span class="line">print(<span class="string">"Collecting data start.. from &#123;&#125; to &#123;&#125;"</span>.format(days_range[<span class="number">0</span>], days_range[<span class="number">-1</span>]))</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line">tweet = got.manager.TweetManager.getTweets(tweetCriteria)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Collecting data end.. &#123;0:0.2f&#125; Minutes"</span>.format((time.time() - start_time)/<span class="number">60</span>))</span><br><span class="line">print(<span class="string">"=== Total num of tweets is &#123;&#125; ==="</span>.format(len(tweet)))</span><br><span class="line"></span><br><span class="line">&gt; Collecting data start.. <span class="keyword">from</span> <span class="number">2019</span><span class="number">-04</span><span class="number">-21</span> to <span class="number">2019</span><span class="number">-04</span><span class="number">-24</span></span><br><span class="line">&gt; Collecting data end.. <span class="number">41.39</span> Minutes</span><br><span class="line">&gt; === Total num of tweets <span class="keyword">is</span> <span class="number">22964</span> ===</span><br></pre></td></tr></table></figure><p>수집하는 데 시간이 조금 걸린다. 참고로 너무 많은 트윗을 한번에 수집하려다 보면, 트위터 측에서 나가라고 쫒아낸다.. (Error 104)</p><p><em>An error occured during an HTTP request: [Errno 104] Connection reset by peer</em></p><p>Connection 관련한 에러가 뜨면, 지정한 날짜 범위에 기준을 만족하는 트윗의 수가 너무 많은 것이니 범위를 좁혀서 다시 시도해 보자.</p><p>수집하는 데 얼마나 시간이 걸렸는지 알아보기 위해 <code>time</code> 을 임포트 해서 코드 몇줄을 추가했다. 참고로 나는 이 과정에서 1시간 넘게 소요된 적도 있었으니 참을성있게 기다려보자.</p><p>위 코드는 41분 가량 소요되었다. 몇개의 트윗이 수집되었는지 출력되면, 아래 단계로 넘어가자.</p><h2 id="변수-저장하기"><a href="#변수-저장하기" class="headerlink" title="변수 저장하기"></a>변수 저장하기</h2><p>이제 원하는 정보만을 저장해 보자. <strong>GetOldTweet3</strong> 에서 제공하는 기본 변수 중 유저 아이디, 트윗 링크, 트윗 내용, 날짜, 리트윗 수, 관심글 수를 수집한다.</p><p>또한, 이 패키지에서 제공하지 않는 변수 중 각 유저의 가입일, 전체 트윗 수, 팔로잉 수, 팔로워 수도 같이 수집한다. 이때, 앞서 준비한 <strong>BeautifulSoup4</strong> 를 사용한다. 자세한 사용 방법은 이전 포스트들을 참고하자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 원하는 변수 골라서 저장하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> uniform</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm_notebook</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize</span></span><br><span class="line">tweet_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> tqdm_notebook(tweet):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 메타데이터 목록 </span></span><br><span class="line">    username = index.username</span><br><span class="line">    link = index.permalink </span><br><span class="line">    content = index.text</span><br><span class="line">    tweet_date = index.date.strftime(<span class="string">"%Y-%m-%d"</span>)</span><br><span class="line">    tweet_time = index.date.strftime(<span class="string">"%H:%M:%S"</span>)</span><br><span class="line">    retweets = index.retweets</span><br><span class="line">    favorites = index.favorites</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># === 유저 정보 수집 시작 ===</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        personal_link = <span class="string">'https://twitter.com/'</span> + username</span><br><span class="line">        bs_obj = get_bs_obj(personal_link)</span><br><span class="line">        uls = bs_obj.find(<span class="string">"ul"</span>, &#123;<span class="string">"class"</span>: <span class="string">"ProfileNav-list"</span>&#125;).find_all(<span class="string">"li"</span>)</span><br><span class="line">        div = bs_obj.find(<span class="string">"div"</span>, &#123;<span class="string">"class"</span>: <span class="string">"ProfileHeaderCard-joinDate"</span>&#125;).find_all(<span class="string">"span"</span>)[<span class="number">1</span>][<span class="string">"title"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 가입일, 전체 트윗 수, 팔로잉 수, 팔로워 수</span></span><br><span class="line">        joined_date = div.split(<span class="string">'-'</span>)[<span class="number">1</span>].strip()</span><br><span class="line">        num_tweets = uls[<span class="number">0</span>].find(<span class="string">"span"</span>, &#123;<span class="string">"class"</span>: <span class="string">"ProfileNav-value"</span>&#125;).text.strip()</span><br><span class="line">        num_following = uls[<span class="number">1</span>].find(<span class="string">"span"</span>, &#123;<span class="string">"class"</span>: <span class="string">"ProfileNav-value"</span>&#125;).text.strip()</span><br><span class="line">        num_follower = uls[<span class="number">2</span>].find(<span class="string">"span"</span>, &#123;<span class="string">"class"</span>: <span class="string">"ProfileNav-value"</span>&#125;).text.strip()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">"=== Attribute error occurs at &#123;&#125; ==="</span>.format(link))</span><br><span class="line">        print(<span class="string">"link : &#123;&#125;"</span>.format(personal_link))   </span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment"># 결과 합치기</span></span><br><span class="line">    info_list = [tweet_date, tweet_time, username, content, link, retweets, favorites, </span><br><span class="line">                 joined_date, num_tweets, num_following, num_follower]</span><br><span class="line">    tweet_list.append(info_list)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 휴식 </span></span><br><span class="line">    time.sleep(uniform(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><strong>(주의: 실행 시 약 24시간이 소요됩니다. 결과를 빨리 확인하려면 유저 정보 수집 부분을 전부 주석처리 해주세요.)</strong></p><p>유저의 가입일, 전체 트윗 수, 팔로잉 수, 팔로워 수 와 같은 변수는 <strong>GetOldTweet3</strong>으로 얻은 <code>username</code>으로 <code>personal_link</code>을 만들어 수집하였다.</p><p>중간에 <code>try-except</code> 구문을 사용하였는데, 이는 수집을 시도해 보니 몇몇 사용자의 팔로잉 수 혹은 팔로워 수가 공개되어 있지 않아 <code>AttributeError</code>을 발생시키고 있었다. 이런 에러를 발생시키는 계정은 보통 광고용 찌라시 계정이었는데, 이를 확인하기 위해 에러 발생시 그 link를 출력하도록 코드를 구성하였다.</p><p>또한, 공격적인 크롤링 방지를 위해 <code>random.uniform()</code>을 활용하여 아래에 1~2초 사이로 랜덤하게 for문을 쉬게 하는 코드를 추가했다.  </p><p>트윗 수집 결과는 <code>tweet_list</code>에 저장된다.</p><h2 id="파일-저장-후-확인"><a href="#파일-저장-후-확인" class="headerlink" title="파일 저장 후 확인"></a>파일 저장 후 확인</h2><p>이제 결과를 csv 파일로 저장하고, 저장된 파일을 불러와서 확인해 보자. <code>Pandas</code> 패키지를 사용할 것이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파일 저장하기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">twitter_df = pd.DataFrame(tweet_list, </span><br><span class="line">                          columns = [<span class="string">"date"</span>, <span class="string">"time"</span>, <span class="string">"user_name"</span>, <span class="string">"text"</span>, <span class="string">"link"</span>, <span class="string">"retweet_counts"</span>, <span class="string">"favorite_counts"</span>,</span><br><span class="line">                                    <span class="string">"user_created"</span>, <span class="string">"user_tweets"</span>, <span class="string">"user_followings"</span>, <span class="string">"user_followers"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv 파일 만들기</span></span><br><span class="line">twitter_df.to_csv(<span class="string">"sample_twitter_data_&#123;&#125;_to_&#123;&#125;.csv"</span>.format(days_range[<span class="number">0</span>], days_range[<span class="number">-1</span>]), index=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">"=== &#123;&#125; tweets are successfully saved ==="</span>.format(len(tweet_list)))</span><br><span class="line"></span><br><span class="line">&gt; === <span class="number">22964</span> tweets are successfully saved ===</span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면, working directory 내에 sample_twitter_data_2019-04-21_to_2019-04-24.csv 파일이 생성되었음을 확인할 수 있다.</p><p>생성한 파일을 로드해서 내용을 확인해 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파일 확인하기</span></span><br><span class="line"></span><br><span class="line">df_tweet = pd.read_csv(<span class="string">'sample_twitter_data_&#123;&#125;_to_&#123;&#125;.csv'</span>.format(days_range[<span class="number">0</span>], days_range[<span class="number">-1</span>]))</span><br><span class="line">df_tweet.head(<span class="number">10</span>) <span class="comment"># 위에서 10개만 출력</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/59205137-2d90ac00-8bdd-11e9-9d3b-fdef803b7e6c.png" width="700"></p><h2 id="데이터-통계-확인"><a href="#데이터-통계-확인" class="headerlink" title="데이터 통계 확인"></a>데이터 통계 확인</h2><p>수집한 데이터라 어떤 특징을 보이고 있는지 간단하게 확인해 보자. </p><p><u>어벤져스</u> 또는 <u>스포</u>가 포함된 트윗을 수집하였는데, 각각의 빈도는 어느 정도일까?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 키워드 빈도 분석하기</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_keywords</span><span class="params">(dataframe)</span>:</span></span><br><span class="line">    keywords = []</span><br><span class="line">    text = dataframe[<span class="string">"text"</span>].lower()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"어벤져스"</span> <span class="keyword">in</span> text:</span><br><span class="line">        keywords.append(<span class="string">"어벤져스"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">"스포"</span> <span class="keyword">in</span> text:</span><br><span class="line">        keywords.append(<span class="string">"스포"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">","</span>.join(keywords)</span><br><span class="line"></span><br><span class="line">df_tweet[<span class="string">"keyword"</span>] = df_tweet.apply(get_keywords,axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># barplot 그리기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">counts = df_tweet[<span class="string">"keyword"</span>].value_counts()</span><br><span class="line">plt.bar(range(len(counts)), counts)</span><br><span class="line">plt.title(<span class="string">"Tweets mentioning keywords"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"# of tweets"</span>)</span><br><span class="line">plt.show()</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/59205869-bcea8f00-8bde-11e9-910e-a7e1ba347476.png" width="450"></p><p>barplot을 그릴 때에는 파이썬의 visualization package 중 가장 유명한 <code>matplotlib</code>을 사용했다.</p><p><u>스포</u> 가 단일로 포함된 트윗이 14,782개로 가장 많았고, 그 뒤로 <u>어벤져스</u> 단일이 6,902개 , 그리고 <u>어벤져스</u> 와 <u>스포</u> 모두 포함된 트윗이 1,248개 로 파악된다.</p><p>이번에는 어벤져스 개봉일이 다가오면서 변화하는 트윗의 빈도를 출력해 보자.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 날짜별 빈도 분석하기</span></span><br><span class="line"></span><br><span class="line">counts = df_tweet[<span class="string">"date"</span>].value_counts().sort_index()</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Tweets mentioning keywords in time series"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"# of tweets"</span>)</span><br><span class="line">counts.plot(kind = <span class="string">'bar'</span>)</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/25416425/59206240-7c3f4580-8bdf-11e9-93b4-8803db1e7084.png" width="450"></p><p>역시나 예상했던 대로, 영화 개봉일인 4월 24일이 되자 트윗이 14,989개로 폭발적으로 증가했음을 확인할 수 있다.</p><p>여기까지 간단하게 데이터의 shape 정도를 확인해 보았다. 이외에도 다양한 방법으로 데이터를 분석할 수 있으니 그건 각자 해보는 걸로..</p><p><em>20.02.25 추가</em><br><a href="https://jeongwookie.github.io/2020/02/25/200225-twitter-data-crawling-without-package/">트위터 크롤링, 패키지 없이 해보자!</a> 라는 주제로 새로 블로그에 글을 업로드 하였으니 필요하신 분은 참고 바랍니다.</p><p><em>20.04.23 추가</em><br><a href="https://jeongwookie.github.io/2020/04/23/200423-analyze-tweet-series-1-collect/">트위터 파헤치기 시리즈 첫번째 - 수집하기</a> 라는 트위터 크롤링 관련 포스트를 새로 작성하였습니다. 많은 분들이 댓글로 질문 주셨던 내용들이 여기에 자연스럽게 담겨 있습니다. 일례로, 해당 날짜의 전수 트윗을 모으는 것이 아닌 popular한 100개의 트윗만을 모으는 것도 가능합니다. 자세한 내용은 포스트를 읽어 보시고, 궁금한 점 댓글 달아주세요!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;어떤 사건에 대한 사람들의 즉각적인 관심과 반응, 그리고 영향력자들이 어떻게 일반 사용자에게 영향을 미치는지 분석하는 데는 트위터 만한 SNS가 없다.&lt;/p&gt;
&lt;p&gt;본 포스트에서는 예제로 19년 4월 4주차에서 &lt;u&gt;어벤져스&lt;/u&gt; 또는 &lt;u&gt;스포&lt;/u&gt;가 포함된 트윗을 수집해 볼 것이다.&lt;/p&gt;
&lt;p&gt;어벤져스 엔드게임은 19년 4월 24일에 개봉해서 엄청난 인기를 끌었는데, 한동안 SNS에서 일명 스포 (스포일러)를 한다고 절대 아무거나 클릭하지 말라고 소동이 있었던 것으로 기억한다.&lt;/p&gt;
&lt;p&gt;개봉일 전후로 트윗 수가 차이가 나고, &lt;u&gt;스포&lt;/u&gt;와 같이 작성된 트윗이 많을 것으로 기대된다. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/25416425/59194117-ebf30780-8bc2-11e9-91f1-ab6b84883cd6.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Ⅰ. Data Science" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/"/>
    
      <category term="데이터 크롤링" scheme="https://jeongwookie.github.io/categories/%E2%85%A0-Data-Science/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%AC%EB%A1%A4%EB%A7%81/"/>
    
    
      <category term="Python" scheme="https://jeongwookie.github.io/tags/Python/"/>
    
      <category term="Datamining" scheme="https://jeongwookie.github.io/tags/Datamining/"/>
    
      <category term="Twitter" scheme="https://jeongwookie.github.io/tags/Twitter/"/>
    
  </entry>
  
</feed>
